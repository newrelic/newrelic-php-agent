/*
 * Copyright 2020 New Relic Corporation. All rights reserved.
 * SPDX-License-Identifier: Apache-2.0
 */

#include "php_agent.h"
#include "php_call.h"
#include "php_curl.h"
#include "php_curl_md.h"
#include "php_datastore.h"
#include "php_error.h"
#include "php_explain.h"
#include "php_explain_mysqli.h"
#include "php_file_get_contents.h"
#include "php_globals.h"
#include "php_httprequest_send.h"
#include "php_internal_instrument.h"
#include "php_mysql.h"
#include "php_mysqli.h"
#include "php_pdo.h"
#include "php_pgsql.h"
#include "php_redis.h"
#include "php_user_instrument.h"
#include "php_wrapper.h"
#include "nr_datastore_instance.h"
#include "nr_explain.h"
#include "nr_header.h"
#include "nr_segment_datastore.h"
#include "nr_segment_external.h"
#include "nr_txn.h"
#include "util_logging.h"
#include "util_strings.h"
#include "util_url.h"

#include "lib_doctrine2.h"

/*
 * This file adds wrapping instrumentation to a number of statically known
 * php-internal functions.
 *
 * The internal instrumentation scheme within this file is designed for code
 * reuse:  Not only does it allow one instrumentation wrapper
 * to be used for the instrumentation of similar functions, such as sqlite_query
 * and sqlite_unbuffered_query, it also allows each instrumentation wrapper's
 * behavior to depend slightly on the actual function being wrapped.  For
 * example:  Most memcache functions need the same instrumentation, but
 * the metric they generated will vary.
 *
 *
 * In order to add instrumentation for a new internal function, you must do
 * the following:
 *
 *   > Create an auto-generated outer wrapper function for the internal
 * function. This is done using the NR_OUTER_WRAPPER macro.
 *
 *   > Create a handwritten inner wrapper function.  The prototype
 *     of this function is created using the NR_INNER_WRAPPER macro.
 *     This is the wrapper function which will be reused between internal
 *     functions, and therefore this step can be skipped if an existing
 *     inner wrapper with correct behavior can be found.
 *
 *   > Create a wrap record for the function.  This is done in
 *     nr_php_generate_internal_wrap_records using the NR_INTERNAL_WRAPREC
 * macro. This wrap record will reference the function/method name, the outer
 *     wrapper, and the inner wrapper.
 *
 * In order for auto generated outer wrappers to delegate to the proper
 * inner wrapper, each outer wrapper has its own corresponding wrap record
 * global pointer, which is also generated by the NR_OUTER_WRAPPER macro.
 * This pointer's value is assigned to the wrap record during the wrapping
 * process.
 */

/*
 * Here's an example call stack from gdb after
 * the wrappers have been called, in this case for memcache_add;
 *
 *   zif_memcache_add ()
 *   nr_zend_call_old_handler (oldhandler=<zif_memcache_add>, ...)
 *   _nr_inner_wrapper_function_memcache_function (...)
 *   nr_php_instrument_delegate (wraprec=*_nr_outer_wrapper_global_memcache_add,
 * ...) _nr_outer_wrapper_function_memcache_add (...)
 *   zend_do_fcall_common_helper_SPEC (...) at zend_vm_execute.h
 */

/*
 * Inner wrapper function type:
 */
typedef void (*nr_inner_wrapper_fn_t)(INTERNAL_FUNCTION_PARAMETERS,
                                      nrinternalfn_t* fn);

/*
 * Delegation function which bridges between the outer and inner wrappers.
 */
static void nr_php_instrument_delegate(nrinternalfn_t* wraprec,
                                       INTERNAL_FUNCTION_PARAMETERS) {
  if ((NULL == wraprec) || (NULL == wraprec->oldhandler)
      || (NULL == wraprec->inner_wrapper)) {
    /*
     * This conditional should never happen:  The wraprec and its fields
     * should be properly populated during construction.  Perhaps this should
     * be changed into some sort of assertion.
     */
    return;
  }
  if (0 == nr_php_recording(TSRMLS_C)) {
    wraprec->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }
  nr_txn_force_single_count(NRPRG(txn), wraprec->supportability_metric);
  (wraprec->inner_wrapper)(INTERNAL_FUNCTION_PARAM_PASSTHRU, wraprec);
}

#define NR_OUTER_WRAPPER_NAME(RAW) _nr_outer_wrapper_function_##RAW
#define NR_OUTER_GLOBAL_NAME(RAW) _nr_outer_wrapper_global_##RAW
#define NR_INNER_WRAPPER_NAME(RAW) _nr_inner_wrapper_function_##RAW

/*
 * Inner wrapper prototype creation:
 */
#define NR_INNER_WRAPPER(RAW)                                          \
  static void NR_INNER_WRAPPER_NAME(RAW)(INTERNAL_FUNCTION_PARAMETERS, \
                                         nrinternalfn_t * nr_wrapper)

/*
 * Outer wrapper whole function creation:
 */
#if ZEND_MODULE_API_NO < ZEND_7_3_X_API_NO
#define NR_OUTER_WRAPPER(RAW)                                            \
  static nrinternalfn_t* NR_OUTER_GLOBAL_NAME(RAW) = NULL;               \
  static void NR_OUTER_WRAPPER_NAME(RAW)(INTERNAL_FUNCTION_PARAMETERS) { \
    nr_php_instrument_delegate(NR_OUTER_GLOBAL_NAME(RAW),                \
                               INTERNAL_FUNCTION_PARAM_PASSTHRU);        \
  }
#else
#define NR_OUTER_WRAPPER(RAW)                                     \
  static nrinternalfn_t* NR_OUTER_GLOBAL_NAME(RAW) = NULL;           \
  static void ZEND_FASTCALL NR_OUTER_WRAPPER_NAME(RAW)(           \
      INTERNAL_FUNCTION_PARAMETERS) {                             \
    nr_php_instrument_delegate(NR_OUTER_GLOBAL_NAME(RAW),         \
                               INTERNAL_FUNCTION_PARAM_PASSTHRU); \
  }
#endif /* PHP < 7.3 */

/*
 * For explanation, see comment above:
 * nr_zend_call_orig_execute and nr_zend_call_orig_execute_special
 */
int nr_zend_call_old_handler(nrphpfn_t oldhandler,
                             INTERNAL_FUNCTION_PARAMETERS) {
  volatile int zcaught = 0;
  zend_try { oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU); }
  zend_catch { zcaught = 1; }
  zend_end_try();
  return zcaught;
}

/*
 * Wrap an existing function with an instrumentation function. Our technique is
 * to find both functions in the function_table and then to replace just the
 * handler function pointer of the wrapped function: everything else in the
 * function_table stays the same.
 */
void nr_php_wrap_internal_function(nrinternalfn_t* wraprec TSRMLS_DC) {
  char* function_name = NULL;
  char* class_name = NULL;
  zend_function* orig_func = NULL;

  if (wraprec->is_wrapped) {
    return;
  }

  function_name = nr_php_function_name_from_full_name(wraprec->full_name);
  class_name = nr_php_class_name_from_full_name(wraprec->full_name);

  if (NULL == class_name) {
    /*
     * A normal function, with no class.
     */
    orig_func = nr_php_find_function(function_name TSRMLS_CC);
    nr_free(function_name);

    if (NULL == orig_func) {
      /*
       * No log message here, the PHP application being instrumented may not
       * be using the extension with this function.
       */
      return;
    }

    if (ZEND_INTERNAL_FUNCTION != orig_func->type) {
      nrl_warning(NRL_INSTRUMENT,
                  NRP_FMT " in function_table is not an internal function",
                  NRP_PHP(wraprec->full_name));
      return;
      /*
       * If we want to handle ZEND_USER_FUNCTION and ZEND_OVERLOADED_FUNCTION
       * as well as internal binary functions, see zend_vm_def.h and look for
       * zend_do_fcall_common_helper
       */
    }
  } else {
    zend_class_entry* orig_class;

    orig_class = nr_php_find_class(class_name TSRMLS_CC);
    nr_free(class_name);

    if (NULL == orig_class) {
      /*
       * No log message here, the PHP application being instrumented may not
       * be using the extension with this method.
       */
      nr_free(function_name);
      return;
    }

    orig_func = nr_php_find_class_method(orig_class, function_name);
    nr_free(function_name);

    if (NULL == orig_func) {
      nrl_verbosedebug(NRL_INSTRUMENT,
                       "did not find function in " NRP_FMT
                       "'s class function_table",
                       NRP_PHP(wraprec->full_name));
      return;
    }

    if (ZEND_INTERNAL_FUNCTION != orig_func->type) {
      nrl_warning(NRL_INSTRUMENT, NRP_FMT " is not an internal function",
                  NRP_PHP(wraprec->full_name));
      return;
    }
  }

  /*
   * If the internal function is disabled, don't wrap it; doing so breaks
   * function_exists(), and it can't be invoked anyway.
   */
  if (zif_display_disabled_function
      == ((zend_internal_function*)orig_func)->handler) {
    nrl_verbosedebug(
        NRL_INSTRUMENT,
        "Skipping instrumentation of disabled internal function " NRP_FMT,
        NRP_PHP(wraprec->full_name));
    return;
  }

  if (wraprec->outer_wrapper_global) {
    /*
     * This conditional should always succeed.  Each wraprec should have
     * an outer_wrapper_global by construction.
     */
    *wraprec->outer_wrapper_global = wraprec;
  }
  wraprec->oldhandler = ((zend_internal_function*)orig_func)->handler;
  ((zend_internal_function*)orig_func)->handler = wraprec->outer_wrapper;
  wraprec->is_wrapped = 1;
}

static void nr_php_internal_wraprec_destroy(nrinternalfn_t** wraprec_ptr) {
  nrinternalfn_t* wraprec = NULL;

  if (NULL == wraprec_ptr) {
    return;
  }
  wraprec = *wraprec_ptr;
  if (NULL == wraprec) {
    return;
  }

  if (wraprec->outer_wrapper_global) {
    *wraprec->outer_wrapper_global = 0;
  }

  nr_free(wraprec->supportability_metric);
  nr_realfree((void**)wraprec_ptr);
}

void nr_php_destroy_internal_wrap_records(void) {
  nrinternalfn_t* next_internal_wraprec = NULL;

  next_internal_wraprec = nr_wrapped_internal_functions;
  while (next_internal_wraprec) {
    nrinternalfn_t* wraprec = next_internal_wraprec;

    next_internal_wraprec = wraprec->next;
    nr_php_internal_wraprec_destroy(&wraprec);
  }

  nr_wrapped_internal_functions = NULL;
}

static void record_mysql_error(TSRMLS_D) {
  char* stack_json = NULL;
  int errprio = nr_php_error_get_priority(E_ERROR);

  if (NR_SUCCESS == nr_txn_record_error_worthy(NRPRG(txn), errprio)) {
    zval* retval_ptr = NULL;
    char* errormsgstr = NULL;
    int errormsglen;
    char* errdup = NULL;

    errormsgstr = "<mysql error>";
    errormsglen = sizeof("<mysql error>");
    retval_ptr = nr_php_call(NULL, "mysql_error");

    if (NULL == retval_ptr) {
      nrl_debug(NRL_INSTRUMENT, "zend_call_function('mysql_error') failed");
    } else if (nr_php_is_zval_valid_string(retval_ptr)) {
      errormsgstr = Z_STRVAL_P(retval_ptr);
      errormsglen = Z_STRLEN_P(retval_ptr);
    } else {
      nrl_debug(NRL_INSTRUMENT, "mysql_error returned %d",
                Z_TYPE_P(retval_ptr));
    }

    errdup = nr_strndup(errormsgstr, errormsglen);
    stack_json = nr_php_backtrace_to_json(0 TSRMLS_CC);
    nr_txn_record_error(NRPRG(txn), errprio, errdup, "MysqlError", stack_json);
    nr_free(errdup);
    nr_free(stack_json);

    nr_php_zval_free(&retval_ptr);
  }
}

/************************************************************************************
 *              I N S T R U M E N T A T I O N   F U N C T I O N S *
 ************************************************************************************/

/*
 * Here's how this works:
 *
 * In the non-instrumented PHP engine, there is a function table which is a
 * hash map of entries like:
 *     foo => (pointer) - - - - - - -> function foo_impl(params) {
 *                                         ...implementation of foo...
 *                                     }
 *
 * Our goal is to replace those entries with
 *     foo => (pointer) - - - - - - -> anonymous function (params) {
 *                                         start timer;
 *                                         foo_impl(params);
 *                                         stop timer;
 *                                     }
 *
 * However, we (1) don't have anonymous functions in C, so we'll need to have
 * named functions, and (2) don't want to directly call foo_impl because we
 * don't actually know that (pointer) will be pointing to foo_impl: there
 * might be other extensions that do the same thing we do, replacing and
 * chaining pointers. So instead we do:
 *
 *     foo => (pointer) - - -> anonymous function (params) {
 *                                 static var ptr = (pointer) - - - - - ->
 * function foo_impl(params) { start timer;                       /-->
 * ...implementation of foo... call
 * (*ptr)(params); --[call to]--/     } stop
 * timer;
 *                             }
 *
 * Or rather the not-anonymous:
 *
 *     foo => (pointer) - - -> function foo_wrapper(params) {
 *                                 static var ptr = (pointer) - - - - - ->
 * function foo_impl(params) { start timer;                       /-->
 * ...implementation of foo... call
 * (*ptr)(params); --[call to]--/     } stop
 * timer;
 *                             }
 *
 * Because the foo_wrapper functions are all so similar, we'd like to reuse
 * a generic function, so the final scheme is:
 *
 *     foo => (pointer) - - -> function foo_wrapper(params) {
 *                                 static var ptr = (pointer) - - - -> function
 * foo_impl(params) { call generic_wrapper(params,ptr);        ...implementation
 * of foo... }                |
 * } [call to]                                ^ |
 * | v
 * | function
 * generic_wrapper(params,ptr) {               |
 *                                  start timer; | call
 * (*ptr)(params);---------------[call
 * to]-----+ stop timer;
 *                              }
 *
 * I call these two wrappers the outer wrapper (e.g. foo_wrapper) and the inner
 * wrapper (e.g. generic_wrapper).
 */

/*
 * Handle
 *   bool mysql_select_db ( string $database_name [, resource $link_identifier =
 * NULL ] )
 */
NR_INNER_WRAPPER(mysql_select_db) {
  char* dbstr = NULL;
  nr_string_len_t dblen;
  zval* mysql = NULL;
  int zcaught = 0;
  nr_datastore_instance_t* instance = NULL;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "s|r", &dbstr,
                                  &dblen, &mysql)) {
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  instance = nr_php_mysql_retrieve_datastore_instance(mysql TSRMLS_CC);
  nr_datastore_instance_set_database_name(instance, dbstr);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

NR_INNER_WRAPPER(mysql_close) {
  zval* mysql = NULL;

  if (FAILURE
      != zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "|r", &mysql)) {
    nr_php_mysql_remove_datastore_instance(mysql TSRMLS_CC);
  }

  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
}

/*
 * Handle
 *   resource mysql_connect ([ string $server = ini_get("mysql.default_host") [,
 * string $username = ini_get("mysql.default_user") [, string $password =
 * ini_get("mysql.default_password") [, bool $new_link = false [, int
 * $client_flags = 0 ]]]]] )
 */
NR_INNER_WRAPPER(mysql_connect) {
  char* host_and_port = NULL;
  int zcaught = 0;

  /*
   * SQL Safe Mode, see:
   * http://php.net/manual/en/ini.core.php#ini.sql.safe-mode
   * http://php.net/manual/en/function.mysql-connect.php
   */
  if (0 == zend_ini_long(NR_HSTR("sql.safe_mode"), 0)) {
    char* user = NULL;
    char* passwd = NULL;
    nr_string_len_t host_len = 0;
    nr_string_len_t user_len = 0;
    nr_string_len_t passwd_len = 0;
    zend_long ignore1 = 0;
    zend_bool ignore2 = 0;

    if (FAILURE
        == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                    ZEND_NUM_ARGS() TSRMLS_CC, "|s!s!s!l",
                                    &host_and_port, &host_len, &user, &user_len,
                                    &passwd, &passwd_len, &ignore1)) {
      if (FAILURE
          == zend_parse_parameters_ex(
              ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, "|s!s!s!bl",
              &host_and_port, &host_len, &user, &user_len, &passwd, &passwd_len,
              &ignore2, &ignore1)) {
        nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
        return;
      }
    }
  }

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_mysql_save_datastore_instance(return_value, host_and_port TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   resource mysql_xxx ( string $query [, resource $link_identifier ] )
 * functions. This is the inner wrapper function for most mysql functions.
 */
NR_INNER_WRAPPER(mysql_query) {
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;
  zval* mysql = NULL;
  int zcaught = 0;
  nr_segment_t* segment = NULL;
  nr_datastore_instance_t* instance = NULL;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "s|r", &sqlstr,
                                  &sqlstrlen, &mysql)) {
    /*
     * If we can't find a string at all, call the handler without
     * instrumentation
     */
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  instance = nr_php_mysql_retrieve_datastore_instance(mysql TSRMLS_CC);

  nr_php_txn_end_segment_sql(&segment, sqlstr, sqlstrlen, NULL,
                             NR_DATASTORE_MYSQL, instance TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }

  /*
   * If there was a mysql error, register an error.
   */
  if (NRINI(record_database_errors) && nr_php_is_zval_valid_bool(return_value)
      && !nr_php_is_zval_true(return_value)) {
    record_mysql_error(TSRMLS_C);
  }
}

/*
 * Handle
 *   resource mysql_db_query ( string $db, string $query [, resource
 * $link_identifier ] )
 */
NR_INNER_WRAPPER(mysql_db_query) {
  char* sqlstr = NULL;
  char* dbstr = NULL;
  nr_string_len_t dblen;
  nr_string_len_t sqlstrlen;
  zval* mysql = NULL;
  int zcaught = 0;
  nr_segment_t* segment = NULL;
  nr_datastore_instance_t* instance = NULL;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "ss|r", &dbstr,
                                  &dblen, &sqlstr, &sqlstrlen, &mysql)) {
    /*
     * If we can't find a string at all, call the handler without
     * instrumentation.
     */
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  instance = nr_php_mysql_retrieve_datastore_instance(mysql TSRMLS_CC);
  nr_datastore_instance_set_database_name(instance, dbstr);

  nr_php_txn_end_segment_sql(&segment, sqlstr, sqlstrlen, NULL,
                             NR_DATASTORE_MYSQL, instance TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }

  /*
   * If there was a mysql error, register an error.
   */
  if (NRINI(record_database_errors) && nr_php_is_zval_valid_bool(return_value)
      && !nr_php_is_zval_true(return_value)) {
    record_mysql_error(TSRMLS_C);
  }
}

NR_INNER_WRAPPER(mysqli_close) {
  zval* mysqli_obj = NULL;

  if (FAILURE
      != zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "|o",
                                  &mysqli_obj)) {
    nr_php_mysqli_remove_datastore_instance(mysqli_obj TSRMLS_CC);
  }

  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
}

/*
 * Handle
 *   object mysqli_connect ([ string $host = ini_get("mysqli.default_host") [,
 * string $username = ini_get("mysqli.default_user") [, string $passwd =
 * ini_get("mysqli.default_pw") [, string $dbname = "" [, int $port =
 * ini_get("mysqli.default_port") [, string $socket =
 * ini_get("mysqli.default_socket") ]]]]]] object mysqli::__construct ([ string
 * $host = ini_get("mysqli.default_host") [, string $username =
 * ini_get("mysqli.default_user") [, string $passwd =
 * ini_get("mysqli.default_pw") [, string $dbname = "" [, int $port =
 * ini_get("mysqli.default_port") [, string $socket =
 * ini_get("mysqli.default_socket") ]]]]]]
 *
 * This is the inner wrapper function for connecting a new MySQLi link.
 */
NR_INNER_WRAPPER(mysqli_construct) {
  char* host = NULL;
  char* username = NULL;
  char* password = NULL;
  char* database = NULL;
  char* socket = NULL;
  nr_string_len_t host_len = 0;
  nr_string_len_t username_len = 0;
  nr_string_len_t password_len = 0;
  nr_string_len_t database_len = 0;
  nr_string_len_t socket_len = 0;
  zend_long port = 0;
  zval* mysqli_obj = NULL;
  int zcaught = 0;

  if (FAILURE
      == zend_parse_parameters_ex(
          ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, "|ssssls", &host,
          &host_len, &username, &username_len, &password, &password_len,
          &database, &database_len, &port, &socket, &socket_len)) {
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  if (nr_php_mysqli_zval_is_link(return_value TSRMLS_CC)) {
    mysqli_obj = return_value;
  } else {
    /*
     * We have to get the object instance the constructor has been called on,
     * but because of the way MySQLi object instantiation is handled (with a
     * custom create_object handler), the zval returned by
     * NR_PHP_INTERNAL_FN_THIS actually returns a temporary object with an
     * uninitialised handle. We have to get the real object instance from the
     * current execute data.
     */
    zval* scope = nr_php_execute_scope(EG(current_execute_data));

    if (nr_php_mysqli_zval_is_link(scope TSRMLS_CC)) {
      mysqli_obj = scope;
    }
  }

  nr_php_mysqli_save_datastore_instance(mysqli_obj, host, port, socket,
                                        database TSRMLS_CC);

  if (mysqli_obj && (0 == NRTXNGLOBAL(generating_explain_plan))) {
    char* host_term = host ? nr_strndup(host, host_len) : NULL;
    char* username_term = username ? nr_strndup(username, username_len) : NULL;
    char* password_term = password ? nr_strndup(password, password_len) : NULL;
    char* database_term = database ? nr_strndup(database, database_len) : NULL;
    char* socket_term = socket ? nr_strndup(socket, socket_len) : NULL;

    nr_mysqli_metadata_set_connect(
        NRTXNGLOBAL(mysqli_links),
        (nr_mysqli_metadata_link_handle_t)Z_OBJ_HANDLE_P(mysqli_obj), host_term,
        username_term, password_term, database_term, port, socket_term, 0);

    nr_free(host_term);
    nr_free(username_term);
    nr_free(password_term);
    nr_free(database_term);
    nr_free(socket_term);
  }

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   bool mysqli_options ( object $link, int $option, mixed $value )
 *   bool mysqli::options ( int $option, mixed $value )
 */
NR_INNER_WRAPPER(mysqli_options) {
  zval* mysqli_obj = NULL;
  zend_long option;
  char* value = NULL;
  nr_string_len_t value_len = 0;
  int zcaught = 0;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "ols", &mysqli_obj,
                                  &option, &value, &value_len)) {
    if (FAILURE
        == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                    ZEND_NUM_ARGS() TSRMLS_CC, "ls", &option,
                                    &value, &value_len)) {
      nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
      return;
    } else {
      mysqli_obj = NR_PHP_INTERNAL_FN_THIS();
    }
  }

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  if (value && (0 == NRTXNGLOBAL(generating_explain_plan))
      && nr_php_mysqli_zval_is_link(mysqli_obj TSRMLS_CC)
      && nr_php_is_zval_true(return_value)) {
    char* value_term = nr_strndup(value, value_len);

    nr_mysqli_metadata_set_option(NRTXNGLOBAL(mysqli_links),
                                  Z_OBJ_HANDLE_P(mysqli_obj), option,
                                  value_term);

    nr_free(value_term);
  }

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   object mysqli_real_connect ( object $link [, string $host =
 * ini_get("mysqli.default_host") [, string $username =
 * ini_get("mysqli.default_user") [, string $passwd =
 * ini_get("mysqli.default_pw") [, string $dbname = "" [, int $port =
 * ini_get("mysqli.default_port") [, string $socket =
 * ini_get("mysqli.default_socket") [, int $flags = 0 ]]]]]]] object
 * mysqli::real_connect ([ string $host = ini_get("mysqli.default_host") [,
 * string $username = ini_get("mysqli.default_user") [, string $passwd =
 * ini_get("mysqli.default_pw") [, string $dbname = "" [, int $port =
 * ini_get("mysqli.default_port") [, string $socket =
 * ini_get("mysqli.default_socket") [, int $flags = 0 ]]]]]]]
 *
 * This is the inner wrapper function for connecting an existing MySQLi link.
 * The astute reader will note that this is very similar to the
 * mysqli_construct inner wrapper above: these haven't been unified because of
 * the differences in handling the object context between a constructor and a
 * non-constructor method.
 */
NR_INNER_WRAPPER(mysqli_real_connect) {
  char* host = NULL;
  char* username = NULL;
  char* password = NULL;
  char* database = NULL;
  char* socket = NULL;
  nr_string_len_t host_len = 0;
  nr_string_len_t username_len = 0;
  nr_string_len_t password_len = 0;
  nr_string_len_t database_len = 0;
  nr_string_len_t socket_len = 0;
  zend_long flags = 0;
  zend_long port = 0;
  zval* mysqli_obj = NULL;
  int zcaught = 0;

  if (FAILURE
      == zend_parse_parameters_ex(
          ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, "o|sssslsl",
          &mysqli_obj, &host, &host_len, &username, &username_len, &password,
          &password_len, &database, &database_len, &port, &socket, &socket_len,
          &flags)) {
    if (FAILURE
        == zend_parse_parameters_ex(
            ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, "|sssslsl",
            &host, &host_len, &username, &username_len, &password,
            &password_len, &database, &database_len, &port, &socket,
            &socket_len, &flags)) {
      nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
      return;
    } else {
      mysqli_obj = NR_PHP_INTERNAL_FN_THIS();
    }
  }

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_mysqli_save_datastore_instance(mysqli_obj, host, port, socket,
                                        database TSRMLS_CC);

  if ((0 == NRTXNGLOBAL(generating_explain_plan))
      && nr_php_mysqli_zval_is_link(mysqli_obj TSRMLS_CC)) {
    char* host_term = host ? nr_strndup(host, host_len) : NULL;
    char* username_term = username ? nr_strndup(username, username_len) : NULL;
    char* password_term = password ? nr_strndup(password, password_len) : NULL;
    char* database_term = database ? nr_strndup(database, database_len) : NULL;
    char* socket_term = socket ? nr_strndup(socket, socket_len) : NULL;

    nr_mysqli_metadata_set_connect(
        NRTXNGLOBAL(mysqli_links),
        (nr_mysqli_metadata_link_handle_t)Z_OBJ_HANDLE_P(mysqli_obj), host_term,
        username_term, password_term, database_term, port, socket_term, flags);

    nr_free(host_term);
    nr_free(username_term);
    nr_free(password_term);
    nr_free(database_term);
    nr_free(socket_term);
  }

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   bool mysqli_select_db ( object $link, string $dbname )
 *   bool mysqli::select_db ( string $dbname )
 */
NR_INNER_WRAPPER(mysqli_select_db) {
  char* database = NULL;
  nr_string_len_t database_len = 0;
  zval* mysqli_obj = NULL;
  int zcaught = 0;
  nr_datastore_instance_t* instance = NULL;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "os", &mysqli_obj,
                                  &database, &database_len)) {
    if (FAILURE
        == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                    ZEND_NUM_ARGS() TSRMLS_CC, "s", &database,
                                    &database_len)) {
      nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
      return;
    } else {
      mysqli_obj = NR_PHP_INTERNAL_FN_THIS();
    }
  }

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  instance = nr_php_mysqli_retrieve_datastore_instance(mysqli_obj TSRMLS_CC);
  nr_datastore_instance_set_database_name(instance, database);

  if (database && (0 == NRTXNGLOBAL(generating_explain_plan))
      && nr_php_mysqli_zval_is_link(mysqli_obj TSRMLS_CC)
      && nr_php_is_zval_true(return_value)) {
    char* database_term = nr_strndup(database, database_len);

    nr_mysqli_metadata_set_database(NRTXNGLOBAL(mysqli_links),
                                    Z_OBJ_HANDLE_P(mysqli_obj), database_term);

    nr_free(database_term);
  }

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   resource mysqli_xxx ( object $link, string $query )
 *   resource mysqli_xxx ( object $link, string $query [, int $resultmode ])
 *
 * This is the inner wrapper function for most of the mysqli functions.
 */
NR_INNER_WRAPPER(mysqli_general_query) {
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen = 0;
  zend_long ignore1;
  zval* mysqli_obj = NULL;
  int zcaught = 0;
  nr_segment_t* segment = NULL;

  /*
   * We should be zend_parse_method_parameters but we don't actually
   * care if this is a correct call, so we just use zend_parse_parameters
   * because then we don't have to pass along the class type for
   * verification of this.
   */

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "os|l",
                                  &mysqli_obj, &sqlstr, &sqlstrlen, &ignore1)) {
    if (FAILURE
        == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                    ZEND_NUM_ARGS() TSRMLS_CC, "s|l", &sqlstr,
                                    &sqlstrlen, &ignore1)) {
      sqlstr = "(unknown sql)";
      sqlstrlen = nr_strlen(sqlstr);
    } else {
      mysqli_obj = NR_PHP_INTERNAL_FN_THIS();
    }
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  if (nrlikely(NULL != segment)) {
    nr_datastore_instance_t* instance = NULL;
    nr_explain_plan_t* plan = NULL;

    /*
     * Set the stop time now so that we don't include the explain plan time.
     */
    segment->stop_time = nr_txn_now_rel(NRPRG(txn));
    instance = nr_php_mysqli_retrieve_datastore_instance(mysqli_obj TSRMLS_CC);

    if ((0 == NRTXNGLOBAL(generating_explain_plan))
        && nr_php_mysqli_zval_is_link(mysqli_obj TSRMLS_CC)) {
      plan = nr_php_explain_mysqli_query(NRPRG(txn), mysqli_obj, sqlstr,
                                         sqlstrlen, segment->start_time,
                                         segment->stop_time TSRMLS_CC);
    }

    nr_php_txn_end_segment_sql(&segment, sqlstr, sqlstrlen, plan,
                               NR_DATASTORE_MYSQL, instance TSRMLS_CC);

    nr_explain_plan_destroy(&plan);
  }

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

#define NR_PHP_PREPARED_STATEMENT_UNKNOWN "(prepared statement)"

/*
 * Use this function to find prepared statements that cannot be uniquely
 * identified by a single resource or object number. The caller is
 * responsible for constructing a suitable composite key.
 */
static const char* nr_php_prepared_statement_find_internal(
    const char* key TSRMLS_DC) {
  const char* stmt = NULL;

  stmt = nr_hashmap_get(NRTXNGLOBAL(prepared_statements), key, nr_strlen(key));
  if (NULL == stmt) {
    stmt = NR_PHP_PREPARED_STATEMENT_UNKNOWN;
  }
  return stmt;
}

/*
 * Use this function to find prepared statements that can be uniquely
 * identified by a single resource or object number. A suitable key
 * will be derived from the given zval.
 */
static const char* nr_php_prepared_statement_find(const zval* obj,
                                                  const char* extension
                                                      TSRMLS_DC) {
  char* key = NULL;
  const char* stmt = NULL;

  key = nr_php_datastore_make_key(obj, extension);
  stmt = nr_php_prepared_statement_find_internal(key TSRMLS_CC);
  nr_free(key);
  return stmt;
}

/*
 * Use this function to save prepared statements that cannot be uniquely
 * identified by a single resource or object number. The caller is
 * responsible for constructing a suitable composite key.
 */
static void nr_php_prepared_statement_save_internal(const char* key,
                                                    const char* stmt,
                                                    nr_string_len_t stmt_len
                                                        TSRMLS_DC) {
  if ((NULL == key) || (NULL == stmt) || (0 == stmt_len)) {
    return;
  }

  nr_hashmap_update(NRTXNGLOBAL(prepared_statements), key, nr_strlen(key),
                    nr_strndup(stmt, stmt_len));
}

/*
 * Use this function to save prepared statements that can be uniquely
 * identified by a single resource or object number. A suitable key
 * will be derived from the given zval and extension name.
 */
static void nr_php_prepared_statement_save(const zval* obj,
                                           const char* extension,
                                           const char* stmt,
                                           nr_string_len_t stmt_len TSRMLS_DC) {
  char* key = NULL;

  key = nr_php_datastore_make_key(obj, extension);
  if (NULL != key) {
    nr_php_prepared_statement_save_internal(key, stmt, stmt_len TSRMLS_CC);
    nr_free(key);
  }
}

NR_INNER_WRAPPER(pdostatement_execute) {
  zval* stmt_obj = NULL;
  zval* parameters = NULL;
  const char* sqlstr = NULL;
  int sqlstrlen;
  int zcaught = 0;
  nr_segment_t* segment = NULL;

  /*
   * It's immaterial if this fails: if there aren't any parameters, we proceed
   * regardless, since we then fall back onto the parameters previously bound
   * to the statement object.
   */
  (void)zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                 ZEND_NUM_ARGS() TSRMLS_CC, "|a!", &parameters);

  stmt_obj = NR_PHP_INTERNAL_FN_THIS();

  sqlstr = nr_php_prepared_statement_find(stmt_obj, "pdo" TSRMLS_CC);
  sqlstrlen = nr_strlen(sqlstr);

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_pdo_end_segment_sql(segment, sqlstr, sqlstrlen, stmt_obj, parameters,
                             true TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   bool mysqli_stmt_bind_param ( object $mysqli_stmt, string $types, mixed
 * &$var1 [, mixed &$... ] ) bool mysqli_stmt::bind_param ( string $types, mixed
 * &$var1 [, mixed &$... ] )
 */
NR_INNER_WRAPPER(mysqli_stmt_bind_param) {
  size_t argc;
  size_t args_to_skip = 0;
  zval** argv = NULL;
  size_t i;
  zval* mysqli_stmt_obj = NULL;
  zval* types = NULL;
  int zcaught = 0;

  /*
   * Don't track bound parameters if we're in the midst of rebinding parameters
   * for an EXPLAIN query: we'll never look at the metadata, and it saves us
   * some work below.
   */
  if (NRTXNGLOBAL(generating_explain_plan)) {
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }

  /*
   * In essence, we need to figure out whether this function has been called in
   * procedural or object oriented mode, because that will determine what
   * position the first bound parameter is in. We track the number of
   * parameters to skip in args_to_skip: this will be 2 in procedural mode (as
   * the first two parameters will be the mysqli_stmt object and the format
   * string), and 1 in OO mode (as the mysqli_stmt object doesn't come in as a
   * parameter).
   *
   * The original plan was to rewrite this using the * parameter format once we
   * dropped PHP 5.2 support, but PHP 5 and 7 are wildly incompatible in how
   * they implement support for that (PHP 5 returns a zval ***; PHP 7 returns a
   * zval *), so rather than implement a shim, we'll stick with this more
   * manual, but working, parameter parsing code.
   */
  argc = (size_t)ZEND_NUM_ARGS();
  argv = (zval**)nr_calloc(argc, sizeof(zval*));
  for (i = 0; i < argc; i++) {
#if ZEND_MODULE_API_NO >= ZEND_5_5_X_API_NO
    argv[i]
        = nr_php_get_user_func_arg(i + 1, EG(current_execute_data) TSRMLS_CC);
#else /* PHP < 5.5 */
    argv[i] = nr_php_get_user_func_arg(i + 1, EG(active_op_array) TSRMLS_CC);
#endif
  }

  /*
   * If this hasn't been called as an object method, then the first parameter
   * should be a mysqli_stmt object.
   */
  mysqli_stmt_obj = NR_PHP_INTERNAL_FN_THIS();
  if (NULL == mysqli_stmt_obj) {
    if (nr_php_mysqli_zval_is_stmt(argv[0] TSRMLS_CC)) {
      mysqli_stmt_obj = argv[0];
      args_to_skip = 1;
    }
  }

  /*
   * The next argument should be a format string.
   */
  if (nr_php_mysqli_zval_is_stmt(mysqli_stmt_obj TSRMLS_CC)
      && nr_php_is_zval_valid_string(argv[args_to_skip])) {
    types = argv[args_to_skip];
    args_to_skip++;
  }

  /*
   * If we didn't get a format string or don't have any remaining parameters,
   * then we should bail.
   */
  if ((NULL == types) || (args_to_skip >= argc)) {
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    goto end;
  }

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_mysqli_query_set_bind_params(
      Z_OBJ_HANDLE_P(mysqli_stmt_obj), Z_STRVAL_P(types), Z_STRLEN_P(types),
      argc - args_to_skip, &argv[args_to_skip] TSRMLS_CC);

end:
  nr_free(argv);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   resource mysqli_stmt_execute ( object $link )
 *   resource mysqli_stmt::execute()
 */
NR_INNER_WRAPPER(mysqli_stmt_execute) {
  zval* stmt_obj = NULL;
  const char* sqlstr = NULL;
  int sqlstrlen;
  int zcaught = 0;
  nr_segment_t* segment = NULL;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "o", &stmt_obj)) {
    stmt_obj = NR_PHP_INTERNAL_FN_THIS();
  }
  sqlstr = nr_php_prepared_statement_find(stmt_obj, "mysqli" TSRMLS_CC);
  sqlstrlen = nr_strlen(sqlstr);

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  if (nrlikely(NULL != segment)) {
    nr_explain_plan_t* plan = NULL;

    segment->stop_time = nr_txn_now_rel(NRPRG(txn));

    if ((0 == NRTXNGLOBAL(generating_explain_plan))
        && nr_php_mysqli_zval_is_stmt(stmt_obj TSRMLS_CC)) {
      plan = nr_php_explain_mysqli_stmt(NRPRG(txn), Z_OBJ_HANDLE_P(stmt_obj),
                                        segment->start_time,
                                        segment->stop_time TSRMLS_CC);
    }

    nr_php_txn_end_segment_sql(&segment, sqlstr, sqlstrlen, plan,
                               NR_DATASTORE_MYSQL, NULL TSRMLS_CC);

    nr_explain_plan_destroy(&plan);
  }

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

static void nr_php_prepared_prepare_general(INTERNAL_FUNCTION_PARAMETERS,
                                            nrinternalfn_t* nr_wrapper,
                                            const char* extension) {
  zval* conn_obj = NULL;
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;
  zval* ignore1 = NULL;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "os", &conn_obj,
                                  &sqlstr, &sqlstrlen)) {
    if (zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                 ZEND_NUM_ARGS() TSRMLS_CC, "s|z", &sqlstr,
                                 &sqlstrlen, &ignore1)
        == FAILURE) {
      nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
      return;
    } else {
      conn_obj = NR_PHP_INTERNAL_FN_THIS();
    }
  }
  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
  nr_php_prepared_statement_save(return_value, extension, sqlstr,
                                 sqlstrlen TSRMLS_CC);

  if ((0 == NRTXNGLOBAL(generating_explain_plan))
      && nr_php_mysqli_zval_is_stmt(return_value TSRMLS_CC)
      && nr_php_mysqli_zval_is_link(conn_obj TSRMLS_CC)
      && nr_php_explain_mysql_query_is_explainable(sqlstr, sqlstrlen)) {
    nr_php_mysqli_query_set_link(Z_OBJ_HANDLE_P(return_value),
                                 conn_obj TSRMLS_CC);

    nr_php_mysqli_query_set_query(Z_OBJ_HANDLE_P(return_value), sqlstr,
                                  sqlstrlen TSRMLS_CC);
  }
}

/*
 * Handle
 *   mysqli_stmt mysqli_prepare( mysqli $link, string $query)
 *   mysqli_stmt mysqli::prepare( string $query )
 */
NR_INNER_WRAPPER(mysqli_prepare) {
  nr_php_prepared_prepare_general(INTERNAL_FUNCTION_PARAM_PASSTHRU, nr_wrapper,
                                  "mysqli");
}

/*
 * Handle
 *   PDOStatement PDO::prepare( string $query [, array $options ])
 */
NR_INNER_WRAPPER(pdo_prepare) {
  nr_php_prepared_prepare_general(INTERNAL_FUNCTION_PARAM_PASSTHRU, nr_wrapper,
                                  "pdo");
}

/*
 * Handle
 *   mysqli_stmt::__construct(mysqli $link [, string $query ])
 */
NR_INNER_WRAPPER(mysqli_stmt_construct) {
  zval* mysqli_obj = NULL;
  zval* this_obj = NULL;
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen = 0;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "o|s", &mysqli_obj,
                                  &sqlstr, &sqlstrlen)) {
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }

  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);

  this_obj = NR_PHP_INTERNAL_FN_THIS();
  if (NULL == this_obj) {
    nrl_verbosedebug(NRL_FRAMEWORK, "%s: cannot obtain 'this'", __func__);
    return;
  }

  if (sqlstr) {
    nr_php_prepared_statement_save(this_obj, "mysqli", sqlstr,
                                   sqlstrlen TSRMLS_CC);
  }

  if ((0 == NRTXNGLOBAL(generating_explain_plan))
      && nr_php_is_zval_valid_object(return_value)
      && nr_php_mysqli_zval_is_stmt(this_obj TSRMLS_CC)
      && nr_php_mysqli_zval_is_link(mysqli_obj TSRMLS_CC)) {
    nr_php_mysqli_query_set_link(Z_OBJ_HANDLE_P(return_value),
                                 mysqli_obj TSRMLS_CC);

    if (nr_php_explain_mysql_query_is_explainable(sqlstr, sqlstrlen)) {
      nr_php_mysqli_query_set_query(Z_OBJ_HANDLE_P(return_value), sqlstr,
                                    sqlstrlen TSRMLS_CC);
    }
  }
}

/*
 * Handle
 *   object mysqli_stmt_init ( object $link )
 *   object mysqli::stmt_init ()
 */
NR_INNER_WRAPPER(mysqli_stmt_init) {
  zval* mysqli_obj = NULL;
  int zcaught = 0;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "o",
                                  &mysqli_obj)) {
    mysqli_obj = NR_PHP_INTERNAL_FN_THIS();
  }

  if (NRTXNGLOBAL(generating_explain_plan)
      || !nr_php_mysqli_zval_is_link(mysqli_obj TSRMLS_CC)) {
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  if (nr_php_mysqli_zval_is_stmt(return_value TSRMLS_CC)) {
    nr_php_mysqli_query_set_link(Z_OBJ_HANDLE_P(return_value),
                                 mysqli_obj TSRMLS_CC);
  }

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   bool mysqli_stmt_prepare( mysqli_stmt $stmt, string $query)
 *   mixed mysqli_stmt::prepare( string $squery )
 */
NR_INNER_WRAPPER(mysqli_stmt_prepare) {
  zval* mysqli_stmt_obj = NULL;
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "os",
                                  &mysqli_stmt_obj, &sqlstr, &sqlstrlen)) {
    if (FAILURE
        == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                    ZEND_NUM_ARGS() TSRMLS_CC, "s", &sqlstr,
                                    &sqlstrlen)) {
      nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
      return;
    } else {
      mysqli_stmt_obj = NR_PHP_INTERNAL_FN_THIS();
    }
  }

  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
  nr_php_prepared_statement_save(mysqli_stmt_obj, "mysqli", sqlstr,
                                 sqlstrlen TSRMLS_CC);

  if ((0 == NRTXNGLOBAL(generating_explain_plan))
      && nr_php_mysqli_zval_is_stmt(mysqli_stmt_obj TSRMLS_CC)
      && nr_php_explain_mysql_query_is_explainable(sqlstr, sqlstrlen)) {
    nr_php_mysqli_query_set_query(Z_OBJ_HANDLE_P(mysqli_stmt_obj), sqlstr,
                                  sqlstrlen TSRMLS_CC);
  }
}

static void nr_php_instrument_datastore_operation_call(
    const nrinternalfn_t* nr_wrapper,
    nr_datastore_t datastore,
    const char* operation,
    nr_datastore_instance_t* instance,
    INTERNAL_FUNCTION_PARAMETERS) {
  int zcaught = 0;
  nr_segment_t* segment = NULL;
  nr_segment_datastore_params_t params = {
    .datastore = {
      .type = datastore,
    },
    .operation = nr_strdup(operation),
    .instance  = instance,
    .callbacks = {
      .backtrace = nr_php_backtrace_callback,
    },
  };

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);
  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_segment_datastore_end(&segment, &params);

  nr_free(params.operation);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   bool memcache_xxx( ... )
 */
NR_INNER_WRAPPER(memcache_function) {
  nr_php_instrument_datastore_operation_call(nr_wrapper, NR_DATASTORE_MEMCACHE,
                                             nr_wrapper->extra, NULL,
                                             INTERNAL_FUNCTION_PARAM_PASSTHRU);
}

/*
 * Handle
 *   bool redis::connect ( string $host[, int $port = 6379 ... ] )
 *   bool redis::pconnect ( string $host[, int $port = 6379 ... ] )
 *   bool redis::open ( string $host[, int $port = 6379 ... ] )
 *   bool redis::popen ( string $host[, int $port = 6379 ... ] )
 */
NR_INNER_WRAPPER(redis_connect) {
  char* host = NULL;
  nr_string_len_t host_len = 0;
  zend_long port = nr_php_redis_default_port;
  zval* ignore1 = NULL;
  zval* ignore2 = NULL;
  zval* ignore3 = NULL;
  nr_datastore_instance_t* instance = NULL;

  if (SUCCESS
      == zend_parse_parameters_ex(
          ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, "s|lzzz", &host,
          &host_len, &port, &ignore1, &ignore2, &ignore3)) {
    instance = nr_php_redis_save_datastore_instance(
        NR_PHP_INTERNAL_FN_THIS(), host,
        port TSRMLS_CC);
  }

  nr_php_instrument_datastore_operation_call(nr_wrapper, NR_DATASTORE_REDIS,
                                             nr_wrapper->extra, instance,
                                             INTERNAL_FUNCTION_PARAM_PASSTHRU);
}

/*
 * Handle
 *   bool redis::close ()
 */
NR_INNER_WRAPPER(redis_close) {
  zval* this_obj = NR_PHP_INTERNAL_FN_THIS();
  nr_php_redis_remove_datastore_instance(this_obj TSRMLS_CC);

  if (nr_zend_call_old_handler(nr_wrapper->oldhandler,
                               INTERNAL_FUNCTION_PARAM_PASSTHRU)) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   bool redis::select ( int $dbindex )
 */
NR_INNER_WRAPPER(redis_select) {
  zend_long dbindex = 0;
  zval* this_obj = NULL;

  if (SUCCESS
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "l", &dbindex)) {
    nr_datastore_instance_t* instance;
    char* database = nr_formatf("%ld", (long)dbindex);

    this_obj = NR_PHP_INTERNAL_FN_THIS();
    instance = nr_php_redis_retrieve_datastore_instance(this_obj TSRMLS_CC);
    nr_datastore_instance_set_database_name(instance, database);
    nr_free(database);
  }

  if (nr_zend_call_old_handler(nr_wrapper->oldhandler,
                               INTERNAL_FUNCTION_PARAM_PASSTHRU)) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   bool redis::*
 */
NR_INNER_WRAPPER(redis_function) {
  nr_datastore_instance_t* instance;
  zval* this_obj = NULL;

  this_obj = NR_PHP_INTERNAL_FN_THIS();

  instance = nr_php_redis_retrieve_datastore_instance(this_obj TSRMLS_CC);

  nr_php_instrument_datastore_operation_call(nr_wrapper, NR_DATASTORE_REDIS,
                                             nr_wrapper->extra, instance,
                                             INTERNAL_FUNCTION_PARAM_PASSTHRU);
}

static char* nr_php_prepared_statement_make_pgsql_key(
    const zval* conn,
    const char* stmtname,
    nr_string_len_t stmtname_len) {
  char* key = NULL;

  /*
   * The pgsql extension doesn't provide a unique resource or object
   * to identify prepared statements. Instead, we construct a key by
   * concatenating the statement name with the resource id for the
   * connection. We expect this value to be sufficiently unique
   * because non-empty statement names cannot be reused.
   */

  if (nr_php_is_zval_valid_resource(conn)) {
    key = nr_formatf("type=pgsql id=%ld name=%.*s",
                     nr_php_zval_resource_id(conn), NRSAFELEN(stmtname_len),
                     stmtname);
  } else {
    key = nr_formatf("type=pgsql id=default name=%.*s", NRSAFELEN(stmtname_len),
                     stmtname);
  }

  return key;
}

/*
 * Handle
 *    bool pg_close ([ resource $connection ] )
 */
NR_INNER_WRAPPER(pg_close) {
  zval* pgsql = NULL;

  if (FAILURE
      != zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "|r", &pgsql)) {
    nr_php_pgsql_remove_datastore_instance(pgsql TSRMLS_CC);
  }

  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
}

/*
 * Handle
 *    resource pg_connect ( string $connection_string [, int $connect_type ] )
 */
NR_INNER_WRAPPER(pg_connect) {
  char* conn_info = NULL;
  nr_string_len_t conn_infolen = 0;
  zend_long ignore1;
  int zcaught;

  /*
   * There is also a very old deprecated syntax with multiple parameters
   * that could not empirically be determined whether it still worked and has
   * therefore been left out of the initial datastore instance instrumentation.
   */
  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "s|l", &conn_info,
                                  &conn_infolen, &ignore1)) {
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_pgsql_save_datastore_instance(return_value, conn_info TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   resource pg_execute(resource $conn, string $stmtname, array params)
 */
NR_INNER_WRAPPER(pg_execute) {
  zval* conn = NULL;
  zval* params = NULL;
  const char* query = NULL;
  char* stmtname = NULL;
  nr_string_len_t stmtname_len = 0;
  nr_datastore_instance_t* instance = NULL;
  int argc;
  int rv;
  int zcaught = 0;
  nr_segment_t* segment = NULL;

  rv = FAILURE;
  argc = ZEND_NUM_ARGS();

  switch (argc) {
    case 3:
      rv = zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
                                    "rsa/", &conn, &stmtname, &stmtname_len,
                                    &params);
      break;
    case 2:
      rv = zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
                                    "sa/", &stmtname, &stmtname_len, &params);
      break;
  }

  if (SUCCESS == rv) {
    char* key;

    /*
     * Note: The instrumentation for pg_prepare/pg_execute relies on the
     * user to be consistent and either pass the connection to both functions,
     * or pass the connection to neither. If they mix-and-match, we will not
     * generate the same key for lookup as for insert.
     */
    key = nr_php_prepared_statement_make_pgsql_key(conn, stmtname,
                                                   stmtname_len);
    query = nr_php_prepared_statement_find_internal(key TSRMLS_CC);
    nr_free(key);

    instance = nr_php_pgsql_retrieve_datastore_instance(conn TSRMLS_CC);
  }

  if (NULL == query) {
    query = NR_PHP_PREPARED_STATEMENT_UNKNOWN;
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);
  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);
  nr_php_txn_end_segment_sql(&segment, query, nr_strlen(query), NULL,
                             NR_DATASTORE_POSTGRES, instance TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   resource pg_prepare(resource $conn, string $stmtname, string $query)
 */
NR_INNER_WRAPPER(pg_prepare) {
  zval* conn = NULL;
  char* stmtname = NULL;
  char* query = NULL;
  nr_string_len_t stmtname_len = 0;
  nr_string_len_t query_len = 0;
  int argc;
  int rv;

  rv = FAILURE;
  argc = ZEND_NUM_ARGS();

  switch (argc) {
    case 3:
      rv = zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
                                    "rss", &conn, &stmtname, &stmtname_len,
                                    &query, &query_len);
      break;
    case 2:
      rv = zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, argc TSRMLS_CC,
                                    "ss", &stmtname, &stmtname_len, &query,
                                    &query_len);
      break;
  }

  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);

  if ((SUCCESS == rv) && (query_len > 0)) {
    char* key = NULL;

    /*
     * Note: The instrumentation for pg_prepare/pg_execute relies on the
     * user to be consistent and either pass the connection to both functions,
     * or pass the connection to neither. If they mix-and-match, we will not
     * generate the same key for lookup as for insert.
     */
    key = nr_php_prepared_statement_make_pgsql_key(conn, stmtname,
                                                   stmtname_len);
    nr_php_prepared_statement_save_internal(key, query, query_len TSRMLS_CC);
    nr_free(key);
  }
}

/*
 * Handle
 *   pg_query (string) and pg_query (resource, string)
 */
NR_INNER_WRAPPER(pg_query) {
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;
  int argc;
  zval* pgsql_link = NULL;
  nr_datastore_instance_t* instance = NULL;
  int zcaught = 0;
  nr_segment_t* segment = NULL;

  argc = ZEND_NUM_ARGS();

  if (1 == argc) {
    if (FAILURE
        == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                    ZEND_NUM_ARGS() TSRMLS_CC, "s", &sqlstr,
                                    &sqlstrlen)) {
      sqlstr = "(unknown sql)";
      sqlstrlen = nr_strlen(sqlstr);
    }
  } else {
    if (FAILURE
        == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                    ZEND_NUM_ARGS() TSRMLS_CC, "rs",
                                    &pgsql_link, &sqlstr, &sqlstrlen)) {
      sqlstr = "(unknown sql)";
      sqlstrlen = nr_strlen(sqlstr);
    }
  }

  /*
   * If pgsql_link is not provided, pgsql uses the last connection made by
   * pg_connect or pg_pconnect. The retrieve method handles this case.
   */
  instance = nr_php_pgsql_retrieve_datastore_instance(pgsql_link TSRMLS_CC);

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);
  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_txn_end_segment_sql(&segment, sqlstr, sqlstrlen, NULL,
                             NR_DATASTORE_POSTGRES, instance TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   pg_query_params (string, array) and pg_query_params (resource, string,
 * array)
 *
 * NOTE: This function allows you to use variable placeholders in the query
 * string like $1, $2 etc whose values come from the array passed as the last
 * argument. We do not currently attempt any such expansion, but rather just use
 * the raw SQL statement as passed to the PHP function. While this will not be
 * the exact SQL that PostgreSQL executes, it will at least be good enough to
 * measure time spent and give the user an idea if a given query is too slow. In
 * the future we may revisit this and attempt actual expansion to produce the
 * full SQL that the server will see.
 */
NR_INNER_WRAPPER(pg_query_params) {
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;
  int argc;
  zval* pgsql_link = NULL;
  zval* param_array = NULL;
  int zcaught = 0;
  nr_segment_t* segment = NULL;

  argc = ZEND_NUM_ARGS();
  if (argc == 2) {
    if (FAILURE
        == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                    ZEND_NUM_ARGS() TSRMLS_CC, "sa", &sqlstr,
                                    &sqlstrlen, &param_array)) {
      sqlstr = "(unknown sql)";
      sqlstrlen = nr_strlen(sqlstr);
    }
  } else {
    if (FAILURE
        == zend_parse_parameters_ex(
            ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, "rsa",
            &pgsql_link, &sqlstr, &sqlstrlen, &param_array)) {
      sqlstr = "(unknown sql)";
      sqlstrlen = nr_strlen(sqlstr);
    }
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_txn_end_segment_sql(&segment, sqlstr, sqlstrlen, NULL,
                             NR_DATASTORE_POSTGRES, NULL TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   sqlite_query (resource, string, result, errormsg)
 *   sqlite_query (string, resource, result, errormsg)
 * and related query functions
 */
NR_INNER_WRAPPER(sqlite_query_function) {
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;
  zend_long ignores;
  zval* errstr = NULL;
  zval* obj = NULL;
  zval* zdb = NULL;
  int zcaught = 0;
  nr_segment_t* segment = NULL;

  obj = NR_PHP_INTERNAL_FN_THIS();
  if (obj) {
    if (FAILURE
        == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                    ZEND_NUM_ARGS() TSRMLS_CC, "s|lz/", &sqlstr,
                                    &sqlstrlen, &ignores, &errstr)) {
      sqlstr = "(unknown sql)";
      sqlstrlen = nr_strlen(sqlstr);
    }
  } else {
    if (FAILURE
        == zend_parse_parameters_ex(
            ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, "sr|lz/",
            &sqlstr, &sqlstrlen, &zdb, &ignores, &errstr)) {
      if (FAILURE
          == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                      ZEND_NUM_ARGS() TSRMLS_CC, "rs|lz/", &zdb,
                                      &sqlstr, &sqlstrlen, &ignores, &errstr)) {
        sqlstr = "(unknown sql)";
        sqlstrlen = nr_strlen(sqlstr);
      }
    }
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_txn_end_segment_sql(&segment, sqlstr, sqlstrlen, NULL,
                             NR_DATASTORE_SQLITE, NULL TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle sqlite calls
 *   sqlite_exec (resource, string, errormsg)
 *   sqlite_query (string, resource, errormsg)
 */
NR_INNER_WRAPPER(sqlite_exec_or_query) {
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;
  zval* errstr = NULL;
  zval* obj = NULL;
  zval* zdb = NULL;
  int zcaught = 0;
  nr_segment_t* segment = NULL;

  obj = NR_PHP_INTERNAL_FN_THIS();
  if (obj) {
    if (FAILURE
        == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                    ZEND_NUM_ARGS() TSRMLS_CC, "s|z/", &sqlstr,
                                    &sqlstrlen, &errstr)) {
      sqlstr = "(unknown sql)";
      sqlstrlen = nr_strlen(sqlstr);
    }
  } else {
    if (FAILURE
        == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                    ZEND_NUM_ARGS() TSRMLS_CC, "sr", &sqlstr,
                                    &sqlstrlen, &zdb)) {
      if (FAILURE
          == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                      ZEND_NUM_ARGS() TSRMLS_CC, "rs|z/", &zdb,
                                      &sqlstr, &sqlstrlen, &errstr)) {
        sqlstr = "(unknown sql)";
        sqlstrlen = nr_strlen(sqlstr);
      }
    }
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_txn_end_segment_sql(&segment, sqlstr, sqlstrlen, NULL,
                             NR_DATASTORE_SQLITE, NULL TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   sqlite3::query
 *   sqlite3::exec
 */
NR_INNER_WRAPPER(sqlite3) {
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;
  int zcaught = 0;
  nr_segment_t* segment = NULL;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "s", &sqlstr,
                                  &sqlstrlen)) {
    sqlstr = "(unknown sql)";
    sqlstrlen = nr_strlen(sqlstr);
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_txn_end_segment_sql(&segment, sqlstr, sqlstrlen, NULL,
                             NR_DATASTORE_SQLITE, NULL TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   sqlite3::querysingle
 */
NR_INNER_WRAPPER(sqlite3_querysingle) {
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;
  zend_bool entire_row;
  int zcaught = 0;
  int rv;
  nr_segment_t* segment = NULL;

  rv = zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                ZEND_NUM_ARGS() TSRMLS_CC, "s|b", &sqlstr,
                                &sqlstrlen, &entire_row);

  if (FAILURE == rv) {
    sqlstr = "(unknown sql)";
    sqlstrlen = nr_strlen(sqlstr);
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_txn_end_segment_sql(&segment, sqlstr, sqlstrlen, NULL,
                             NR_DATASTORE_SQLITE, NULL TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   PDO::__construct ( string $dsn [, string $username [, string $password [,
 * array $options ]]] )
 */
NR_INNER_WRAPPER(pdo_construct) {
  char* dsn = NULL;
  nr_string_len_t dsn_len = 0;
  char* password = NULL;
  nr_string_len_t password_len = 0;
  zval* options = NULL;
  char* username = NULL;
  nr_string_len_t username_len = 0;
  int zcaught = 0;
  zval* this_obj = NULL;

  /*
   * Our interest here is in persisting the options array, if one is given. If
   * we need to duplicate a PDO connection to get an explain plan, we can get
   * all of the connection metadata from the pdo_dbh_t structure _except_ for
   * the options, so we'll capture the options ourselves.
   */

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "s|s!s!a!", &dsn,
                                  &dsn_len, &username, &username_len, &password,
                                  &password_len, &options)) {
    options = NULL;
  }

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  this_obj = NR_PHP_INTERNAL_FN_THIS();

  /*
   * nr_php_pdo_options_save checks both the PDO object and the options array
   * for validity.
   */
  nr_php_pdo_options_save(this_obj, options TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle
 *   PDO::exec (string)
 */
NR_INNER_WRAPPER(pdo_exec) {
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;
  int zcaught = 0;
  nr_segment_t* segment = NULL;
  zval* this_obj = NULL;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "s", &sqlstr,
                                  &sqlstrlen)) {
    sqlstr = "(unknown sql)";
    sqlstrlen = nr_strlen(sqlstr);
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  this_obj = NR_PHP_INTERNAL_FN_THIS();

  nr_php_pdo_end_segment_sql(segment, sqlstr, sqlstrlen, this_obj, NULL,
                             false TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle PDO::query
 */
NR_INNER_WRAPPER(pdo_query) {
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;
  int zcaught = 0;
  nr_segment_t* segment = NULL;

  if (0 == ZEND_NUM_ARGS()) {
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }

  /*
   * We're only interested in the first parameter, but zend_parse_parameters_ex
   * will fail if the number of parameters given does not match the number of
   * parameters allowed as defined by the format string. Prevent this by
   * always giving a parameter count of 1 instead of ZEND_NUM_ARGS. This will
   * cause zend_parse_parameters_ex to ignore the additional parameters.
   */
  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, 1 TSRMLS_CC, "s",
                                  &sqlstr, &sqlstrlen)) {
    sqlstr = "(unknown sql)";
    sqlstrlen = nr_strlen(sqlstr);
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_pdo_end_segment_sql(segment, sqlstr, sqlstrlen, return_value, NULL,
                             true TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle curl_setopt
 *
 * bool curl_setopt ( resource $ch , int $option , mixed $value )
 */
NR_INNER_WRAPPER(curl_setopt) {
  int rv = FAILURE;
  zval* curlres = NULL;
  zval* curlopt = NULL;
  zval* curlval = NULL;

  if (!NRTXNGLOBAL(curl_ignore_setopt)) {
    rv = zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "zzz", &curlres,
                                  &curlopt, &curlval);

    if (SUCCESS == rv) {
      nr_php_curl_setopt_pre(curlres, curlopt, curlval TSRMLS_CC);
    }
  }

  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);

  if (!NRTXNGLOBAL(curl_ignore_setopt)) {
    if (SUCCESS == rv) {
      nr_php_curl_setopt_post(curlres, curlopt, curlval TSRMLS_CC);
    }
  }
}

/*
 * Handle curl_setopt_array
 *
 * bool curl_setopt_array ( resource $ch , array $options )
 */
NR_INNER_WRAPPER(curl_setopt_array) {
  zval* curlres = NULL;
  zval* options = NULL;
  int rv = FAILURE;

  if (!NRTXNGLOBAL(curl_ignore_setopt)) {
    rv = zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "za", &curlres,
                                  &options);

    if (SUCCESS == rv) {
      nr_php_curl_setopt_array(curlres, options,
                               nr_php_curl_setopt_pre TSRMLS_CC);
    }
  }

  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);

  if (!NRTXNGLOBAL(curl_ignore_setopt)) {
    if (SUCCESS == rv) {
      nr_php_curl_setopt_array(curlres, options,
                               nr_php_curl_setopt_post TSRMLS_CC);
    }
  }
}

/*
 * Handle curl_init
 *
 * resource curl_init ([ string $url = NULL ] )
 */
NR_INNER_WRAPPER(curl_init) {
  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_curl_init(return_value TSRMLS_CC);
}

/*
 * Handle curl_exec
 *
 * mixed curl_exec ( resource $ch )
 */
NR_INNER_WRAPPER(curl_exec) {
  zval* curlres = NULL;
  int zcaught = 0;

  if (SUCCESS
      != zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "r", &curlres)) {
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }

  nr_php_curl_exec_pre(curlres, NULL, NULL TSRMLS_CC);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_curl_exec_post(curlres, false TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle curl_multi_add_handle
 *
 * resource curl_multi_add_handle ( resource $mh, resource $ch )
 */
NR_INNER_WRAPPER(curl_multi_add_handle) {
  nr_segment_t* segment = NULL;
  const char* async_context = NULL;
  zval* multires = NULL;
  zval* curlres = NULL;
  int rv = FAILURE;

  rv = zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                ZEND_NUM_ARGS() TSRMLS_CC, "rr", &multires,
                                &curlres);

  if (SUCCESS == rv) {
    if (nr_php_curl_multi_md_add(multires, curlres TSRMLS_CC)
        && nr_php_curl_multi_md_is_initialized(multires TSRMLS_CC)) {
      /*
       * This handles the case where a curl_multi_add_handle() is called on a
       * curl_multi_exec() that's already executing. We call
       * nr_php_curl_exec_pre() to setup the handle before adding it to the
       * curl multi metadata.
       */
      segment = nr_php_curl_multi_md_get_segment(multires TSRMLS_CC);
      async_context
          = nr_php_curl_multi_md_get_async_context(multires TSRMLS_CC);
      nr_php_curl_exec_pre(curlres, segment, async_context TSRMLS_CC);
    }
  }

  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
}

/*
 * Handle curl_multi_remove_handle
 *
 * resource curl_multi_remove_handle ( resource $mh, resource $ch )
 */
NR_INNER_WRAPPER(curl_multi_remove_handle) {
  nr_segment_t* segment = NULL;
  zval* multires = NULL;
  zval* curlres = NULL;
  int rv = FAILURE;

  rv = zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                ZEND_NUM_ARGS() TSRMLS_CC, "rr", &multires,
                                &curlres);

  if (SUCCESS == rv) {
    if (nr_php_curl_multi_md_remove(multires, curlres TSRMLS_CC)) {
      /*
       * End and discard the segment when curl handle is removed.
       */
      segment = nr_php_curl_md_get_segment(curlres TSRMLS_CC);
      if (NULL != segment) {
        nr_segment_discard(&segment);
      }
    }
  }

  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
}

/*
 * Handle
 *   call_user_func_array
 * Profiling of call_user_func_array is disabled by default.
 * This hook is only used for framework naming.
 * Therefore, it is enabled if a relevant framework is detected.
 *
 * The framework detection code will call
 *   nr_php_add_call_user_func_array_pre_callback
 * to enable profiling of call_user_func_array
 */
NR_INNER_WRAPPER(call_user_func_array) {
  if (NULL != NRPRG(cufa_callback)) {
    zval* args = NULL;
    zend_fcall_info fci;
    zend_fcall_info_cache fcc;

    if (SUCCESS
        != zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                    ZEND_NUM_ARGS() TSRMLS_CC, "fa/", &fci,
                                    &fcc, &args)) {
      nrl_verbosedebug(NRL_INSTRUMENT, "%s: invalid arguments", __func__);
      goto leave;
    }

    if (NULL == fcc.function_handler) {
      nrl_verbosedebug(NRL_INSTRUMENT, "%s: invalid function", __func__);
      goto leave;
    }

    nr_php_call_user_func_array_handler(NRPRG(cufa_callback),
                                        fcc.function_handler, NULL TSRMLS_CC);
  }

leave:
  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
  /*
   * WARNING: If additional code is added here after the call, nr_php_recording
   * must be checked since our API could be called by a user function within.
   */
}

/*
 * Handle
 *   resource mssql_query ( string $query [, resource $link_identifier [, int
 * $batch_size = 0]] )
 */
NR_INNER_WRAPPER(mssql_query) {
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;
  zval** ignore1 = NULL;
  zval** ignore2 = NULL;
  int zcaught = 0;
  nr_segment_t* segment = NULL;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "s|zz", &sqlstr,
                                  &sqlstrlen, &ignore1, &ignore2)) {
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_txn_end_segment_sql(&segment, sqlstr, sqlstrlen, NULL,
                             NR_DATASTORE_MSSQL, NULL TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle MongoCollection::xxxx ( ... ) functions such as:
 *      MongoCollection::find
 *      MongoCollection::findOne
 *      MongoCollection::insert
 *      MongoCollection::remove
 *      MongoCollection::save
 *      MongoCollection::update
 *      MongoCollection::group
 * This is the inner wrapper function for these MongoCollection functions.
 */
NR_INNER_WRAPPER(mongocollection_15) {
  int zcaught = 0;
  char* collection_name = NULL;
  int collection_name_len = 0;
  zval* collectionnamez = NULL;
  zval* this_var = NULL;
  nr_segment_t* segment = NULL;
  nr_segment_datastore_params_t params = {
    .datastore = {
      .type = NR_DATASTORE_MONGODB,
    },
    .operation = nr_strdup(nr_wrapper->extra),
    .callbacks = {
      .backtrace = nr_php_backtrace_callback,
    },
  };

  this_var = NR_PHP_INTERNAL_FN_THIS();
  collectionnamez = nr_php_call(this_var, "__toString");
  if (nr_php_is_zval_valid_string(collectionnamez)) {
    collection_name_len = Z_STRLEN_P(collectionnamez);
    collection_name = (char*)nr_alloca(collection_name_len + 1);
    nr_strxcpy(collection_name, Z_STRVAL_P(collectionnamez),
               collection_name_len);
  } else if (NULL != collectionnamez) {
    nrl_warning(NRL_INSTRUMENT,
                "__toString does not return a string in MongoCollection (%d)",
                Z_TYPE_P(collectionnamez));
  } else {
    nrl_warning(NRL_INSTRUMENT, "__toString returned NULL in MongoCollection");
  }
  nr_php_zval_free(&collectionnamez);

  params.collection = collection_name;

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);
  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);
  nr_segment_datastore_end(&segment, &params);

  nr_free(params.operation);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle ob_flush(), ob_end_flush(), and related for two reasons. One to
 * generate supportability metrics around the use of these functions, and
 * two to aid autorum debugging.
 */
NR_INNER_WRAPPER(ob_flush_common) {
  int zcaught = 0;

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);
  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }

  if (NR_PHP_PROCESS_GLOBALS(special_flags).debug_autorum) {
    nrl_verbosedebug(
        NRL_AUTORUM,
        "autorum: the active output buffer has been flushed via " NRP_FMT,
        NRP_PHP(nr_wrapper->full_name));
  }
}

/*
 * Handle
 *   MongoDB::execute ( ... )
 * This is the inner wrapper function for this MongoDB function.
 */
NR_INNER_WRAPPER(mongodb_execute) {
  nr_php_instrument_datastore_operation_call(nr_wrapper, NR_DATASTORE_MONGODB,
                                             "execute", NULL,
                                             INTERNAL_FUNCTION_PARAM_PASSTHRU);
}

/*
 * Handle oci_parse (resource $connection, string $query)
 */
NR_INNER_WRAPPER(oci_parse) {
  char* sqlstr = NULL;
  nr_string_len_t sqlstrlen;
  zval* ignore1 = NULL;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "rs", &ignore1,
                                  &sqlstr, &sqlstrlen)) {
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }
  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
  nr_php_prepared_statement_save(return_value, "oci", sqlstr,
                                 sqlstrlen TSRMLS_CC);

  return;
}

/*
 * Handle oci_execute() which executes a prepared Oracle statement.
 * This is the inner wrapper function for this Oracle function.
 */
NR_INNER_WRAPPER(oci_execute) {
  zval* stmt_obj = NULL;
  zend_long ignore1;
  const char* sqlstr = NULL;
  int sqlstrlen;
  int zcaught = 0;
  nr_segment_t* segment = NULL;

  if (FAILURE
      == zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "r|l", &stmt_obj,
                                  &ignore1)) {
    nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
    return;
  }

  sqlstr = nr_php_prepared_statement_find(stmt_obj, "oci" TSRMLS_CC);
  sqlstrlen = nr_strlen(sqlstr);

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_txn_end_segment_sql(&segment, sqlstr, sqlstrlen, NULL,
                             NR_DATASTORE_ORACLE, NULL TSRMLS_CC);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle file_get_contents() and see if we are using http[s] as the scheme
 * and record this as an external service call if we are.
 *
 * string file_get_contents ( string $filename [, bool $use_include_path = false
 *                                             [, resource $context
 *                                             [, int $offset = -1
 *                                             [, int $maxlen ]]]] )
 */
NR_INNER_WRAPPER(file_get_contents) {
  nr_status_t rv;
  int zend_rv;
  nr_segment_t* segment = NULL;
  nr_segment_external_params_t external_params
      = {.library = "file_get_contents"};
  zval* file_zval = NULL;
  zval* use_include_path = NULL;
  zval* context = NULL;
  zval* offset = NULL;
  zval* maxlen = NULL;
  zval* method = NULL;
  int zcaught = 0;

  zend_rv = zend_parse_parameters_ex(
      ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, "z|zz!zz", &file_zval,
      &use_include_path, &context, &offset, &maxlen);

  /*
   * Ensure that the file parameter is a string that starts with http. If not,
   * we should bail out of the function so we don't instrument something we
   * don't want to.
   */
  if ((SUCCESS != zend_rv) || (0 == nr_php_is_zval_valid_string(file_zval))
      || (Z_STRLEN_P(file_zval) < 4)
      || (0 != nr_strncmp(Z_STRVAL_P(file_zval), "http", 4))) {
    goto leave;
  }

  if ((NRPRG(txn)->options.cross_process_enabled
       || NRPRG(txn)->options.distributed_tracing_enabled)
      && (0 == context)) {
    /*
     * There is no context parameter.  This is unfortunate because adding
     * cross request headers requires a context parameter.  This context
     * parameter cannot easily be added to the parameters to this call as
     * the parameter list is PHP version specific and the functions which
     * manipulate it are static within zend_execute.h.  Therefore, we instead
     * make a recursive call back into file_get_contents with the original
     * arguments and the addition of a new context.
     */
    rv = nr_php_file_get_contents_recurse_with_context(
        return_value, file_zval, use_include_path, offset, maxlen TSRMLS_CC);
    if (NR_SUCCESS != rv) {
      goto leave;
    }
    return;
  }

  method = nr_php_file_get_contents_get_method(context TSRMLS_CC);
  if (nr_php_is_zval_valid_string(method)) {
    external_params.procedure
        = nr_strndup(Z_STRVAL_P(method), Z_STRLEN_P(method));
  } else {
    // file_get_contents defaults to GET when a method is not passed in.
    external_params.procedure = nr_strdup("GET");
  }

  external_params.uri
      = nr_strndup(Z_STRVAL_P(file_zval), Z_STRLEN_P(file_zval));

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  nr_php_file_get_contents_add_headers(context, segment TSRMLS_CC);
  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  external_params.encoded_response_header
      = nr_php_file_get_contents_response_header(TSRMLS_C);

  nr_segment_external_end(&segment, &external_params);

  nr_php_file_get_contents_remove_headers(context TSRMLS_CC);

  if (NRPRG(txn) && NRTXN(special_flags.debug_cat)) {
    nrl_verbosedebug(
        NRL_CAT,
        "CAT: outbound response: transport='file_get_contents' %s=" NRP_FMT,
        X_NEWRELIC_APP_DATA, NRP_CAT(external_params.encoded_response_header));
  }

  nr_free(external_params.procedure);
  nr_free(external_params.encoded_response_header);
  nr_free(external_params.uri);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }

  return;

leave:
  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
}

/*
 * Handle curl_multi_exec.
 */
NR_INNER_WRAPPER(curl_multi_exec) {
  int zcaught = 0;
  zval* curlres = NULL;
  zend_long still_running;

  if (SUCCESS
      != zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET,
                                  ZEND_NUM_ARGS() TSRMLS_CC, "rl", &curlres,
                                  &still_running)) {
    goto leave;
  }

  nr_php_curl_multi_exec_pre(curlres TSRMLS_CC);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  nr_php_curl_multi_exec_post(curlres TSRMLS_CC);

  /*
   * Parameters are re-parsed, as the actual call to curl_multi_exec has
   * set the value of the `still_running` reference parameter.
   *
   * If this parameter is set to 0, this is an indicator that
   * curl_multi_exec is done. nr_php_curl_multi_exec_finalize is called
   * to clean up any curl handles for which no request could be made and
   * which are still lingering.
   */
  zend_parse_parameters_ex(ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC,
                           "rl", &curlres, &still_running);

  if (0 == still_running) {
    nr_php_curl_multi_exec_finalize(curlres TSRMLS_CC);
  }

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }

  return;

leave:
  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);
}

/*
 * Handle http version < 2.0 HttpRequest::Send
 */
NR_INNER_WRAPPER(httprequest_send) {
  int zcaught = 0;
  zval* this_var = NULL;
  nr_segment_t* segment = NULL;
  nr_segment_external_params_t external_params = {.library = "pecl_http 1"};

  this_var = NR_PHP_INTERNAL_FN_THIS();

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);

  nr_php_httprequest_send_request_headers(this_var, segment TSRMLS_CC);
  external_params.uri = nr_php_httprequest_send_get_url(this_var TSRMLS_CC);

  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);

  external_params.encoded_response_header
      = nr_php_httprequest_send_response_header(this_var TSRMLS_CC);

  external_params.status
      = nr_php_httprequest_send_response_code(this_var TSRMLS_CC);

  nr_segment_external_end(&segment, &external_params);

  if (NRPRG(txn) && NRTXN(special_flags.debug_cat)) {
    nrl_verbosedebug(
        NRL_CAT, "CAT: outbound response: transport='pecl_http 1' %s=" NRP_FMT,
        X_NEWRELIC_APP_DATA, NRP_CAT(external_params.encoded_response_header));
  }

  nr_free(external_params.encoded_response_header);
  nr_free(external_params.uri);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle SoapClient::__doRequest
 */
NR_INNER_WRAPPER(soapclient_dorequest) {
  int rv;
  int zcaught;
  nr_segment_t* segment = NULL;
  nr_segment_external_params_t external_params
      = {.uri = NULL, .library = "SoapClient"};
  nr_string_len_t buf_len = 0;
  nr_string_len_t loc_len = 0;
  nr_string_len_t action_len = 0;
  char* buf = NULL;
  char* loc = NULL;
  char* action = NULL;
  zend_long version = 0;
  zend_long one_way = 0;

  rv = zend_parse_parameters_ex(
      ZEND_PARSE_PARAMS_QUIET, ZEND_NUM_ARGS() TSRMLS_CC, "sssl|l", &buf,
      &buf_len, &loc, &loc_len, &action, &action_len, &version, &one_way);

  if (FAILURE != rv) {
    external_params.uri = nr_strndup(loc, loc_len);
  }

  segment = nr_segment_start(NRPRG(txn), NULL, NULL);
  zcaught = nr_zend_call_old_handler(nr_wrapper->oldhandler,
                                     INTERNAL_FUNCTION_PARAM_PASSTHRU);
  nr_segment_external_end(&segment, &external_params);

  nr_free(external_params.uri);

  if (zcaught) {
    zend_bailout();
    /* NOTREACHED */
  }
}

/*
 * Handle dl(). We're not interested in true instrumentation here; we just need
 * to trigger a rescan of the extensions if we're instrumenting them after dl
 * executes.
 */
NR_INNER_WRAPPER(dl) {
  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);

  if (NR_PHP_PROCESS_GLOBALS(instrument_extensions)) {
    nr_php_extension_instrument_rescan(NRPRG(extensions) TSRMLS_CC);
  }
}

static inline int nr_php_should_instrument_exception_handler(
    zval* handler TSRMLS_DC) {
  if (0 == NRINI(ignore_user_exception_handler)) {
    if (handler) {
      /*
       * Instrument any valid callable that is _not_
       * "newrelic_exception_handler".
       */
      if (nr_php_is_zval_valid_callable(handler TSRMLS_CC)) {
        if (nr_php_is_zval_valid_string(handler)
            && (0
                == nr_strncmp("newrelic_exception_handler", Z_STRVAL_P(handler),
                              Z_STRLEN_P(handler)))) {
          return 0;
        }

        return 1;
      }
    }
  }

  return 0;
}

/*
 * Handle restore_exception_handler() and set_exception_handler().
 *
 * We're not instrumenting these functions per se, but if the last exception
 * handler (ours!) is removed we need to re-add it to ensure that we catch and
 * report exceptions appropriately, and we also need to instrument the
 * currently active exception handler if it's not newrelic_exception_handler so
 * that we can generate errors from uncaught exceptions.
 */
NR_INNER_WRAPPER(exception_common) {
  zval* exception_handler = NULL;

#ifdef PHP7
  exception_handler = &EG(user_exception_handler);
#else
  exception_handler = EG(user_exception_handler);
#endif

  /*
   * Remove instrumentation from the current exception handler, if any.
   */
  if (nr_php_should_instrument_exception_handler(exception_handler TSRMLS_CC)) {
    zend_function* func;

    func = nr_php_zval_to_function(exception_handler TSRMLS_CC);
    nr_php_remove_exception_function(func TSRMLS_CC);
  }

  /*
   * Actually call whichever of set_error_handler() or restore_error_handler()
   * was originally called.
   */
  nr_wrapper->oldhandler(INTERNAL_FUNCTION_PARAM_PASSTHRU);

#ifdef PHP7
  exception_handler = &EG(user_exception_handler);
#else
  exception_handler = EG(user_exception_handler);
#endif

  /*
   * Add instrumentation to the new exception handler, if any.
   */
  if (nr_php_should_instrument_exception_handler(exception_handler TSRMLS_CC)) {
    zend_function* func;

    func = nr_php_zval_to_function(exception_handler TSRMLS_CC);
    nr_php_add_exception_function(func TSRMLS_CC);
#ifdef PHP7
  } else if (IS_UNDEF == Z_TYPE_P(exception_handler)) {
#else
  } else if (NULL == exception_handler) {
#endif /* PHP7 */
    nr_php_error_install_exception_handler(TSRMLS_C);
  }
}

NR_OUTER_WRAPPER(mysql_select_db)
NR_OUTER_WRAPPER(mysql_selectdb)
NR_OUTER_WRAPPER(mysql_close)
NR_OUTER_WRAPPER(mysql_connect)
NR_OUTER_WRAPPER(mysql_pconnect)
NR_OUTER_WRAPPER(mysql_query)
NR_OUTER_WRAPPER(mysql_unbuffered_query)
NR_OUTER_WRAPPER(mysql_db_query)

NR_OUTER_WRAPPER(mysqli_close)
NR_OUTER_WRAPPER(mysqli_connect)
NR_OUTER_WRAPPER(mysqli_multi_query)
NR_OUTER_WRAPPER(mysqli_options)
NR_OUTER_WRAPPER(mysqli_prepare)
NR_OUTER_WRAPPER(mysqli_query)
NR_OUTER_WRAPPER(mysqli_real_connect)
NR_OUTER_WRAPPER(mysqli_real_query)
NR_OUTER_WRAPPER(mysqli_select_db)
NR_OUTER_WRAPPER(mysqli_stmt_init)

NR_OUTER_WRAPPER(mysqliC_construct)
NR_OUTER_WRAPPER(mysqliC_multi_query)
NR_OUTER_WRAPPER(mysqliC_options)
NR_OUTER_WRAPPER(mysqliC_prepare)
NR_OUTER_WRAPPER(mysqliC_query)
NR_OUTER_WRAPPER(mysqliC_real_connect)
NR_OUTER_WRAPPER(mysqliC_real_query)
NR_OUTER_WRAPPER(mysqliC_select_db)
NR_OUTER_WRAPPER(mysqliC_stmt_init)

NR_OUTER_WRAPPER(mysqli_stmt_bind_param)
NR_OUTER_WRAPPER(mysqli_stmt_execute)
NR_OUTER_WRAPPER(mysqli_stmt_prepare)

NR_OUTER_WRAPPER(mysqli_stmtC_construct)
NR_OUTER_WRAPPER(mysqli_stmtC_bind_param)
NR_OUTER_WRAPPER(mysqli_stmtC_execute)
NR_OUTER_WRAPPER(mysqli_stmtC_prepare)

NR_OUTER_WRAPPER(memcache_connect)
NR_OUTER_WRAPPER(memcache_pconnect)
NR_OUTER_WRAPPER(memcache_add)
NR_OUTER_WRAPPER(memcache_set)
NR_OUTER_WRAPPER(memcache_replace)
NR_OUTER_WRAPPER(memcache_get)
NR_OUTER_WRAPPER(memcache_delete)
NR_OUTER_WRAPPER(memcache_increment)
NR_OUTER_WRAPPER(memcache_decrement)

NR_OUTER_WRAPPER(memcacheC_connect)
NR_OUTER_WRAPPER(memcacheC_pconnect)
NR_OUTER_WRAPPER(memcacheC_add)
NR_OUTER_WRAPPER(memcacheC_set)
NR_OUTER_WRAPPER(memcacheC_replace)
NR_OUTER_WRAPPER(memcacheC_get)
NR_OUTER_WRAPPER(memcacheC_delete)
NR_OUTER_WRAPPER(memcacheC_increment)
NR_OUTER_WRAPPER(memcacheC_decrement)

NR_OUTER_WRAPPER(memcached_add)
NR_OUTER_WRAPPER(memcached_addbykey)
NR_OUTER_WRAPPER(memcached_append)
NR_OUTER_WRAPPER(memcached_appendbykey)
NR_OUTER_WRAPPER(memcached_cas)
NR_OUTER_WRAPPER(memcached_casbykey)
NR_OUTER_WRAPPER(memcached_decrement)
NR_OUTER_WRAPPER(memcached_delete)
NR_OUTER_WRAPPER(memcached_deletebykey)
NR_OUTER_WRAPPER(memcached_get)
NR_OUTER_WRAPPER(memcached_getbykey)
NR_OUTER_WRAPPER(memcached_getdelayed)
NR_OUTER_WRAPPER(memcached_getdelayedbykey)
NR_OUTER_WRAPPER(memcached_getmulti)
NR_OUTER_WRAPPER(memcached_getmultibykey)
NR_OUTER_WRAPPER(memcached_increment)
NR_OUTER_WRAPPER(memcached_prepend)
NR_OUTER_WRAPPER(memcached_prependbykey)
NR_OUTER_WRAPPER(memcached_replace)
NR_OUTER_WRAPPER(memcached_replacebykey)
NR_OUTER_WRAPPER(memcached_set)
NR_OUTER_WRAPPER(memcached_setbykey)
NR_OUTER_WRAPPER(memcached_setmulti)
NR_OUTER_WRAPPER(memcached_setmultibykey)

NR_OUTER_WRAPPER(redis_connect)
NR_OUTER_WRAPPER(redis_pconnect)
NR_OUTER_WRAPPER(redis_open)
NR_OUTER_WRAPPER(redis_popen)
NR_OUTER_WRAPPER(redis_close)
NR_OUTER_WRAPPER(redis_select)
NR_OUTER_WRAPPER(redis_del)
NR_OUTER_WRAPPER(redis_delete)
NR_OUTER_WRAPPER(redis_get)
NR_OUTER_WRAPPER(redis_set)
NR_OUTER_WRAPPER(redis_setex)
NR_OUTER_WRAPPER(redis_setnx)
NR_OUTER_WRAPPER(redis_incr)
NR_OUTER_WRAPPER(redis_incrby)
NR_OUTER_WRAPPER(redis_decr)
NR_OUTER_WRAPPER(redis_decrby)
NR_OUTER_WRAPPER(redis_lset)
NR_OUTER_WRAPPER(redis_lget)
NR_OUTER_WRAPPER(redis_lrem)
NR_OUTER_WRAPPER(redis_lremove)
NR_OUTER_WRAPPER(redis_lindex)
NR_OUTER_WRAPPER(redis_hset)
NR_OUTER_WRAPPER(redis_hsetnx)
NR_OUTER_WRAPPER(redis_hget)
NR_OUTER_WRAPPER(redis_hmset)
NR_OUTER_WRAPPER(redis_hmget)

NR_OUTER_WRAPPER(pg_close)
NR_OUTER_WRAPPER(pg_connect)
NR_OUTER_WRAPPER(pg_pconnect)
NR_OUTER_WRAPPER(pg_execute)
NR_OUTER_WRAPPER(pg_prepare)
NR_OUTER_WRAPPER(pg_query)
NR_OUTER_WRAPPER(pg_query_params)

NR_OUTER_WRAPPER(sqlite_query)
NR_OUTER_WRAPPER(sqlite_unbuffered_query)

NR_OUTER_WRAPPER(sqlite_exec)
NR_OUTER_WRAPPER(sqlitedatabaseC_query)
NR_OUTER_WRAPPER(sqlitedatabaseC_unbuffered_query)
NR_OUTER_WRAPPER(sqlitedatabaseC_exec)

NR_OUTER_WRAPPER(sqlite3_query)
NR_OUTER_WRAPPER(sqlite3_querysingle)
NR_OUTER_WRAPPER(sqlite3_exec)

NR_OUTER_WRAPPER(pdo_construct)
NR_OUTER_WRAPPER(pdo_query)
NR_OUTER_WRAPPER(pdo_exec)
NR_OUTER_WRAPPER(pdo_prepare)

NR_OUTER_WRAPPER(pdostmt_execute)

NR_OUTER_WRAPPER(curl_exec)
NR_OUTER_WRAPPER(curl_setopt)
NR_OUTER_WRAPPER(curl_setopt_array)
NR_OUTER_WRAPPER(curl_init)
NR_OUTER_WRAPPER(curl_multi_add_handle)
NR_OUTER_WRAPPER(curl_multi_remove_handle)

NR_OUTER_WRAPPER(call_user_func_array)

NR_OUTER_WRAPPER(mssql_query)

NR_OUTER_WRAPPER(mongoC_find)
NR_OUTER_WRAPPER(mongoC_findone)
NR_OUTER_WRAPPER(mongoC_insert)
NR_OUTER_WRAPPER(mongoC_remove)
NR_OUTER_WRAPPER(mongoC_save)
NR_OUTER_WRAPPER(mongoC_update)
NR_OUTER_WRAPPER(mongoC_group)

NR_OUTER_WRAPPER(mongodb_execute)

NR_OUTER_WRAPPER(oci_parse)
NR_OUTER_WRAPPER(oci_execute)

NR_OUTER_WRAPPER(file_get_contents)
NR_OUTER_WRAPPER(curl_multi_exec)
NR_OUTER_WRAPPER(httprequest_send)

NR_OUTER_WRAPPER(flush)
NR_OUTER_WRAPPER(ob_flush)
NR_OUTER_WRAPPER(ob_clean)
NR_OUTER_WRAPPER(ob_end_flush)
NR_OUTER_WRAPPER(ob_end_clean)
NR_OUTER_WRAPPER(ob_get_clean)
NR_OUTER_WRAPPER(ob_get_flush)
NR_OUTER_WRAPPER(ob_implicit_flush)
NR_OUTER_WRAPPER(ob_gzhandler)

NR_OUTER_WRAPPER(soapclient_dorequest)

NR_OUTER_WRAPPER(dl)

NR_OUTER_WRAPPER(set_exception_handler)
NR_OUTER_WRAPPER(restore_exception_handler)

nrinternalfn_t* nr_wrapped_internal_functions = NULL;

static nrinternalfn_t* nr_get_wraprec(void) {
  nrinternalfn_t* p = (nrinternalfn_t*)nr_zalloc(sizeof(nrinternalfn_t));

  p->next = nr_wrapped_internal_functions;
  nr_wrapped_internal_functions = p;
  return p;
}

void nr_php_generate_internal_wrap_records(void) {
  nrinternalfn_t* w = NULL;

  /*
   * If we've generated the internal function structures once,
   * that's all we need to do it.
   * (Historically, this was in a table filled out at compile time.)
   */
  if (nr_wrapped_internal_functions) {
    return;
  }

#define NR_INTERNAL_WRAPREC(FULL_NAME, OUTER, INNER, DISABLED, EXTRA) \
  {                                                                   \
    w = nr_get_wraprec();                                             \
    w->full_name = FULL_NAME;                                         \
    w->outer_wrapper_global = &NR_OUTER_GLOBAL_NAME(OUTER);           \
    w->inner_wrapper = NR_INNER_WRAPPER_NAME(INNER);                  \
    w->outer_wrapper = NR_OUTER_WRAPPER_NAME(OUTER);                  \
    w->is_disabled = DISABLED;                                        \
    w->extra = EXTRA;                                                 \
    w->supportability_metric                                          \
        = nr_txn_create_fn_supportability_metric(FULL_NAME, NULL);    \
  }
  /*
   *                   Function or Class::Method Name     Outer Wrapper
   * Inner Wrapper                  Disabled |
   * |                          | |  Extra v
   * v                          v v  v
   */
  NR_INTERNAL_WRAPREC("mysql_select_db", mysql_select_db, mysql_select_db, 0, 0)
  NR_INTERNAL_WRAPREC("mysql_selectdb", mysql_selectdb, mysql_select_db, 0, 0)
  NR_INTERNAL_WRAPREC("mysql_close", mysql_close, mysql_close, 0, 0)
  NR_INTERNAL_WRAPREC("mysql_connect", mysql_connect, mysql_connect, 0, 0)
  NR_INTERNAL_WRAPREC("mysql_pconnect", mysql_pconnect, mysql_connect, 0, 0)
  NR_INTERNAL_WRAPREC("mysql_query", mysql_query, mysql_query, 0, 0)
  NR_INTERNAL_WRAPREC("mysql_unbuffered_query", mysql_unbuffered_query,
                      mysql_query, 0, 0)
  NR_INTERNAL_WRAPREC("mysql_db_query", mysql_db_query, mysql_db_query, 0, 0)

  NR_INTERNAL_WRAPREC("mysqli_close", mysqli_close, mysqli_close, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_connect", mysqli_connect, mysqli_construct, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_multi_query", mysqli_multi_query,
                      mysqli_general_query, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_options", mysqli_options, mysqli_options, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_prepare", mysqli_prepare, mysqli_prepare, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_query", mysqli_query, mysqli_general_query, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_real_query", mysqli_real_query,
                      mysqli_general_query, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_real_connect", mysqli_real_connect,
                      mysqli_real_connect, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_select_db", mysqli_select_db, mysqli_select_db, 0,
                      0)
  NR_INTERNAL_WRAPREC("mysqli_stmt_init", mysqli_stmt_init, mysqli_stmt_init, 0,
                      0)

#ifdef PHP7
  NR_INTERNAL_WRAPREC("mysqli::__construct", mysqliC_construct,
                      mysqli_construct, 0, 0)
#else
  NR_INTERNAL_WRAPREC("mysqli::mysqli", mysqliC_construct, mysqli_construct, 0,
                      0)
#endif /* PHP7 */

  NR_INTERNAL_WRAPREC("mysqli::multi_query", mysqliC_multi_query,
                      mysqli_general_query, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli::options", mysqliC_options, mysqli_options, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli::prepare", mysqliC_prepare, mysqli_prepare, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli::query", mysqliC_query, mysqli_general_query, 0,
                      0)
  NR_INTERNAL_WRAPREC("mysqli::real_connect", mysqliC_real_connect,
                      mysqli_real_connect, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli::real_query", mysqliC_real_query,
                      mysqli_general_query, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli::select_db", mysqliC_select_db, mysqli_select_db,
                      0, 0)
  NR_INTERNAL_WRAPREC("mysqli::stmt_init", mysqliC_stmt_init, mysqli_stmt_init,
                      0, 0)

  NR_INTERNAL_WRAPREC("mysqli_stmt_bind_param", mysqli_stmt_bind_param,
                      mysqli_stmt_bind_param, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_stmt_execute", mysqli_stmt_execute,
                      mysqli_stmt_execute, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_stmt_prepare", mysqli_stmt_prepare,
                      mysqli_stmt_prepare, 0, 0)

  NR_INTERNAL_WRAPREC("mysqli_stmt::__construct", mysqli_stmtC_construct,
                      mysqli_stmt_construct, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_stmt::bind_param", mysqli_stmtC_bind_param,
                      mysqli_stmt_bind_param, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_stmt::execute", mysqli_stmtC_execute,
                      mysqli_stmt_execute, 0, 0)
  NR_INTERNAL_WRAPREC("mysqli_stmt::prepare", mysqli_stmtC_prepare,
                      mysqli_stmt_prepare, 0, 0)

  NR_INTERNAL_WRAPREC("memcache_connect", memcache_connect, memcache_function,
                      0, "connect")
  NR_INTERNAL_WRAPREC("memcache_pconnect", memcache_pconnect, memcache_function,
                      0, "connect")
  NR_INTERNAL_WRAPREC("memcache_add", memcache_add, memcache_function, 0, "add")
  NR_INTERNAL_WRAPREC("memcache_set", memcache_set, memcache_function, 0, "set")
  NR_INTERNAL_WRAPREC("memcache_replace", memcache_replace, memcache_function,
                      0, "replace")
  NR_INTERNAL_WRAPREC("memcache_get", memcache_get, memcache_function, 0, "get")
  NR_INTERNAL_WRAPREC("memcache_delete", memcache_delete, memcache_function, 0,
                      "delete")
  NR_INTERNAL_WRAPREC("memcache_increment", memcache_increment,
                      memcache_function, 0, "incr")
  NR_INTERNAL_WRAPREC("memcache_decrement", memcache_decrement,
                      memcache_function, 0, "decr")

  NR_INTERNAL_WRAPREC("memcache::connect", memcacheC_connect, memcache_function,
                      0, "connect")
  NR_INTERNAL_WRAPREC("memcache::pconnect", memcacheC_pconnect,
                      memcache_function, 0, "connect")
  NR_INTERNAL_WRAPREC("memcache::add", memcacheC_add, memcache_function, 0,
                      "add")
  NR_INTERNAL_WRAPREC("memcache::set", memcacheC_set, memcache_function, 0,
                      "set")
  NR_INTERNAL_WRAPREC("memcache::replace", memcacheC_replace, memcache_function,
                      0, "replace")
  NR_INTERNAL_WRAPREC("memcache::get", memcacheC_get, memcache_function, 0,
                      "get")
  NR_INTERNAL_WRAPREC("memcache::delete", memcacheC_delete, memcache_function,
                      0, "delete")
  NR_INTERNAL_WRAPREC("memcache::increment", memcacheC_increment,
                      memcache_function, 0, "incr")
  NR_INTERNAL_WRAPREC("memcache::decrement", memcacheC_decrement,
                      memcache_function, 0, "decr")

  NR_INTERNAL_WRAPREC("memcached::add", memcached_add, memcache_function, 0,
                      "add")
  NR_INTERNAL_WRAPREC("memcached::addbykey", memcached_addbykey,
                      memcache_function, 0, "add")
  NR_INTERNAL_WRAPREC("memcached::append", memcached_append, memcache_function,
                      0, "replace")
  NR_INTERNAL_WRAPREC("memcached::appendbykey", memcached_appendbykey,
                      memcache_function, 0, "replace")
  NR_INTERNAL_WRAPREC("memcached::cas", memcached_cas, memcache_function, 0,
                      "replace")
  NR_INTERNAL_WRAPREC("memcached::casbykey", memcached_casbykey,
                      memcache_function, 0, "replace")
  NR_INTERNAL_WRAPREC("memcached::decrement", memcached_decrement,
                      memcache_function, 0, "decr")
  NR_INTERNAL_WRAPREC("memcached::delete", memcached_delete, memcache_function,
                      0, "delete")
  NR_INTERNAL_WRAPREC("memcached::deletebykey", memcached_deletebykey,
                      memcache_function, 0, "delete")
  NR_INTERNAL_WRAPREC("memcached::get", memcached_get, memcache_function, 0,
                      "get")
  NR_INTERNAL_WRAPREC("memcached::getbykey", memcached_getbykey,
                      memcache_function, 0, "get")
  NR_INTERNAL_WRAPREC("memcached::getdelayed", memcached_getdelayed,
                      memcache_function, 0, "get")
  NR_INTERNAL_WRAPREC("memcached::getdelayedbykey", memcached_getdelayedbykey,
                      memcache_function, 0, "get")
  NR_INTERNAL_WRAPREC("memcached::getmulti", memcached_getmulti,
                      memcache_function, 0, "get")
  NR_INTERNAL_WRAPREC("memcached::getmultibykey", memcached_getmultibykey,
                      memcache_function, 0, "get")
  NR_INTERNAL_WRAPREC("memcached::increment", memcached_increment,
                      memcache_function, 0, "incr")
  NR_INTERNAL_WRAPREC("memcached::prepend", memcached_prepend,
                      memcache_function, 0, "replace")
  NR_INTERNAL_WRAPREC("memcached::prependbykey", memcached_prependbykey,
                      memcache_function, 0, "replace")
  NR_INTERNAL_WRAPREC("memcached::replace", memcached_replace,
                      memcache_function, 0, "replace")
  NR_INTERNAL_WRAPREC("memcached::replacebykey", memcached_replacebykey,
                      memcache_function, 0, "replace")
  NR_INTERNAL_WRAPREC("memcached::set", memcached_set, memcache_function, 0,
                      "set")
  NR_INTERNAL_WRAPREC("memcached::setbykey", memcached_setbykey,
                      memcache_function, 0, "set")
  NR_INTERNAL_WRAPREC("memcached::setmulti", memcached_setmulti,
                      memcache_function, 0, "set")
  NR_INTERNAL_WRAPREC("memcached::setmultibykey", memcached_setmultibykey,
                      memcache_function, 0, "set")

  NR_INTERNAL_WRAPREC("redis::connect", redis_connect, redis_connect, 0,
                      "connect")
  NR_INTERNAL_WRAPREC("redis::pconnect", redis_pconnect, redis_connect, 0,
                      "pconnect")
  NR_INTERNAL_WRAPREC("redis::open", redis_open, redis_connect, 0, "open")
  NR_INTERNAL_WRAPREC("redis::popen", redis_popen, redis_connect, 0, "popen")
  NR_INTERNAL_WRAPREC("redis::close", redis_close, redis_close, 0, "close")
  NR_INTERNAL_WRAPREC("redis::select", redis_select, redis_select, 0, "select")
  NR_INTERNAL_WRAPREC("redis::del", redis_del, redis_function, 0, "del")
  NR_INTERNAL_WRAPREC("redis::delete", redis_delete, redis_function, 0,
                      "delete")
  NR_INTERNAL_WRAPREC("redis::get", redis_get, redis_function, 0, "get")
  NR_INTERNAL_WRAPREC("redis::set", redis_set, redis_function, 0, "set")
  NR_INTERNAL_WRAPREC("redis::setex", redis_setex, redis_function, 0, "setex")
  NR_INTERNAL_WRAPREC("redis::setnx", redis_setnx, redis_function, 0, "setnx")
  NR_INTERNAL_WRAPREC("redis::incr", redis_incr, redis_function, 0, "incr")
  NR_INTERNAL_WRAPREC("redis::incrby", redis_incrby, redis_function, 0,
                      "incrby")
  NR_INTERNAL_WRAPREC("redis::decr", redis_decr, redis_function, 0, "decr")
  NR_INTERNAL_WRAPREC("redis::decrby", redis_decrby, redis_function, 0,
                      "decrby")
  NR_INTERNAL_WRAPREC("redis::lset", redis_lset, redis_function, 0, "lset")
  NR_INTERNAL_WRAPREC("redis::lget", redis_lget, redis_function, 0, "lget")
  NR_INTERNAL_WRAPREC("redis::lrem", redis_lrem, redis_function, 0, "lrem")
  NR_INTERNAL_WRAPREC("redis::lremove", redis_lremove, redis_function, 0,
                      "lremove")
  NR_INTERNAL_WRAPREC("redis::lindex", redis_lindex, redis_function, 0,
                      "lindex")
  NR_INTERNAL_WRAPREC("redis::hset", redis_hset, redis_function, 0, "hset")
  NR_INTERNAL_WRAPREC("redis::hsetnx", redis_hsetnx, redis_function, 0,
                      "hsetnx")
  NR_INTERNAL_WRAPREC("redis::hget", redis_hget, redis_function, 0, "hget")
  NR_INTERNAL_WRAPREC("redis::hmset", redis_hmset, redis_function, 0, "hmset")
  NR_INTERNAL_WRAPREC("redis::hmget", redis_hmget, redis_function, 0, "hmget")

  NR_INTERNAL_WRAPREC("pg_close", pg_close, pg_close, 0, 0)
  NR_INTERNAL_WRAPREC("pg_connect", pg_connect, pg_connect, 0, 0)
  NR_INTERNAL_WRAPREC("pg_pconnect", pg_pconnect, pg_connect, 0, 0)
  NR_INTERNAL_WRAPREC("pg_execute", pg_execute, pg_execute, 0, 0)
  NR_INTERNAL_WRAPREC("pg_prepare", pg_prepare, pg_prepare, 0, 0)
  NR_INTERNAL_WRAPREC("pg_query", pg_query, pg_query, 0, 0)
  NR_INTERNAL_WRAPREC("pg_query_params", pg_query_params, pg_query_params, 0, 0)

  NR_INTERNAL_WRAPREC("sqlite_query", sqlite_query, sqlite_query_function, 0, 0)
  NR_INTERNAL_WRAPREC("sqlite_unbuffered_query", sqlite_unbuffered_query,
                      sqlite_query_function, 0, 0)
  NR_INTERNAL_WRAPREC("sqlite_exec", sqlite_exec, sqlite_exec_or_query, 0, 0)

  NR_INTERNAL_WRAPREC("sqlitedatabase::query", sqlitedatabaseC_query,
                      sqlite_query_function, 0, 0)
  NR_INTERNAL_WRAPREC("sqlitedatabase::unbufferedquery",
                      sqlitedatabaseC_unbuffered_query, sqlite_query_function,
                      0, 0)
  NR_INTERNAL_WRAPREC("sqlitedatabase::queryexec", sqlitedatabaseC_exec,
                      sqlite_exec_or_query, 0, 0)

  NR_INTERNAL_WRAPREC("sqlite3::query", sqlite3_query, sqlite3, 0, 0)
  NR_INTERNAL_WRAPREC("sqlite3::querysingle", sqlite3_querysingle,
                      sqlite3_querysingle, 0, 0)
  NR_INTERNAL_WRAPREC("sqlite3::exec", sqlite3_exec, sqlite3, 0, 0)

  NR_INTERNAL_WRAPREC("pdo::__construct", pdo_construct, pdo_construct, 0, 0)
  NR_INTERNAL_WRAPREC("pdo::query", pdo_query, pdo_query, 0, 0)
  NR_INTERNAL_WRAPREC("pdo::exec", pdo_exec, pdo_exec, 0, 0)
  NR_INTERNAL_WRAPREC("pdo::prepare", pdo_prepare, pdo_prepare, 0, 0)
  NR_INTERNAL_WRAPREC("pdostatement::execute", pdostmt_execute,
                      pdostatement_execute, 0, 0)

  NR_INTERNAL_WRAPREC("curl_exec", curl_exec, curl_exec, 0, 0)
  NR_INTERNAL_WRAPREC("curl_setopt", curl_setopt, curl_setopt, 0, 0)
  NR_INTERNAL_WRAPREC("curl_setopt_array", curl_setopt_array, curl_setopt_array,
                      0, 0)
  NR_INTERNAL_WRAPREC("curl_init", curl_init, curl_init, 0, 0)
  NR_INTERNAL_WRAPREC("curl_multi_add_handle", curl_multi_add_handle,
                      curl_multi_add_handle, 0, 0)
  NR_INTERNAL_WRAPREC("curl_multi_remove_handle", curl_multi_remove_handle,
                      curl_multi_remove_handle, 0, 0)

  /*
   * call_user_func_array is disabled by default:  It is only used for
   * framework naming.  Therefore, it is enabled if a relevant framework
   * is detected.
   */
  NR_INTERNAL_WRAPREC("call_user_func_array", call_user_func_array,
                      call_user_func_array, 1, 0)

  NR_INTERNAL_WRAPREC("mssql_query", mssql_query, mssql_query, 0, 0)

  NR_INTERNAL_WRAPREC("mongocollection::find", mongoC_find, mongocollection_15,
                      0, "find")
  NR_INTERNAL_WRAPREC("mongocollection::findone", mongoC_findone,
                      mongocollection_15, 0, "findone")
  NR_INTERNAL_WRAPREC("mongocollection::insert", mongoC_insert,
                      mongocollection_15, 0, "insert")
  NR_INTERNAL_WRAPREC("mongocollection::remove", mongoC_remove,
                      mongocollection_15, 0, "remove")
  NR_INTERNAL_WRAPREC("mongocollection::save", mongoC_save, mongocollection_15,
                      0, "save")
  NR_INTERNAL_WRAPREC("mongocollection::update", mongoC_update,
                      mongocollection_15, 0, "update")
  NR_INTERNAL_WRAPREC("mongocollection::group", mongoC_group,
                      mongocollection_15, 0, "group")

  NR_INTERNAL_WRAPREC("mongodb::execute", mongodb_execute, mongodb_execute, 0,
                      0)

  NR_INTERNAL_WRAPREC("oci_parse", oci_parse, oci_parse, 0, 0)
  NR_INTERNAL_WRAPREC("oci_execute", oci_execute, oci_execute, 0, 0)

  NR_INTERNAL_WRAPREC("file_get_contents", file_get_contents, file_get_contents,
                      0, 0)
  NR_INTERNAL_WRAPREC("curl_multi_exec", curl_multi_exec, curl_multi_exec, 0, 0)

  /*
   * This is for the php pecl http extension version < 2.0
   */
  NR_INTERNAL_WRAPREC("httprequest::send", httprequest_send, httprequest_send,
                      0, 0)

  NR_INTERNAL_WRAPREC("flush", flush, ob_flush_common, 0, 0)
  NR_INTERNAL_WRAPREC("ob_flush", ob_flush, ob_flush_common, 0, 0)
  NR_INTERNAL_WRAPREC("ob_clean", ob_clean, ob_flush_common, 0, 0)
  NR_INTERNAL_WRAPREC("ob_end_clean", ob_end_clean, ob_flush_common, 0, 0)
  NR_INTERNAL_WRAPREC("ob_end_flush", ob_end_flush, ob_flush_common, 0, 0)
  NR_INTERNAL_WRAPREC("ob_get_clean", ob_get_clean, ob_flush_common, 0, 0)
  NR_INTERNAL_WRAPREC("ob_get_flush", ob_get_flush, ob_flush_common, 0, 0)
  NR_INTERNAL_WRAPREC("ob_implicit_flush", ob_implicit_flush, ob_flush_common,
                      0, 0)
  NR_INTERNAL_WRAPREC("ob_gzhandler", ob_gzhandler, ob_flush_common, 0, 0)

  NR_INTERNAL_WRAPREC("soapclient::__dorequest", soapclient_dorequest,
                      soapclient_dorequest, 0, 0)

  NR_INTERNAL_WRAPREC("dl", dl, dl, 0, 0)

  NR_INTERNAL_WRAPREC("set_exception_handler", set_exception_handler,
                      exception_common, 0, 0)
  NR_INTERNAL_WRAPREC("restore_exception_handler", restore_exception_handler,
                      exception_common, 0, 0)
}

/*
 * Wrap all the interesting internal functions with instrumentation.
 */
void nr_php_add_internal_instrumentation(TSRMLS_D) {
  nrinternalfn_t* w = NULL;

  for (w = nr_wrapped_internal_functions; NULL != w; w = w->next) {
    if ((0 == w->is_wrapped) && (0 == w->is_disabled)) {
      nr_php_wrap_internal_function(w TSRMLS_CC);
    }
  }
}

void nr_php_add_call_user_func_array_pre_callback(
    nrphpcufafn_t callback TSRMLS_DC) {
  nrinternalfn_t* cufa_wraprec = NULL;
  nrinternalfn_t* w = NULL;

  NRPRG(cufa_callback) = callback;

  for (w = nr_wrapped_internal_functions; NULL != w; w = w->next) {
    if (0 == nr_strcmp(w->full_name, "call_user_func_array")) {
      cufa_wraprec = w;
      break;
    }
  }

  if (0 != cufa_wraprec) {
    cufa_wraprec->is_disabled = (NULL == callback);
    nr_php_wrap_internal_function(cufa_wraprec TSRMLS_CC);
  }
}
